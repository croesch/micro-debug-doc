\chapter{Interaktion per Konsole}
\chplbl{bed-konsole}
Wie in \chpref{allgemein} beschrieben, muss der \md{} nicht installiert werden: Vom Herunterladen bis zum Starten des \md{} genügen folgende Schritte.

\begin{enumerate}
\item Die Datei \texttt{micro-debug-version.zip} von der Projektseite\notiz{Verweis auf Seite} herunterladen
\item Die \datei{zip} in ein beliebiges Verzeichnis entpacken (bspw. \texttt{/opt/micro-debug/})
\item Das Verzeichnis des \md{} dem \texttt{PATH} hinzufügen
\item Den \md{} starten -- mit \texttt{\$ micro-debug.sh -{}-help}
\end{enumerate}

Der \md{} kann durch einige Parameter gesteuert werden und wird nach dem Start durch Befehle gesteuert. Sowohl die Parameter als auch die Befehle werden nun erklärt und anschließend wird ein beispielhafter Ablauf mit dem \md{} beschrieben.

\section{Parameter}
Der Standardaufruf für den \md{} ist in \lstref{aufruf-konsolenversion} zu sehen. Es gibt zwei verpflichtende Parameter: Die Pfade zur Mikro-Assembler- und zur Assembler-Bytecode-Datei\notiz{Irgendwo den Aufbau der beiden Dateien erwähnen}. Die beiden Pfade können sowohl relativ als auch absolut angegeben werden, wichtig ist allerdings, dass zuerst der Pfad zur Mikro-Assembler- und dann der Pfad zur assembler-Datei gegeben wird. Werden die beiden Pfade vertauscht, so startet der \md{} nicht und bricht mit einer Fehlermeldung ab.

\begin{lstlisting}[language=sh,caption={Aufruf des \md{} -- Konsolenversion},label=\lstlbl{aufruf-konsolenversion}]
  micro-debug.sh [PARAMETER]... MIC1 IJVM
\end{lstlisting}

Neben den beiden Dateipfaden gibt es im folgende optionale Parameter. Jeder Parameter kann sowohl in der langen (mit doppeltem Minus) als auch in der kurzen (einfaches Minus gefolgt von einem Zeichen) angegeben werden.

\begin{description}
\item[-h, -{}-help]
  ist dieser Parameter gegeben, so wird die Hilfe angezeigt, die neben den verschiedenen Aufrufmöglichkeiten die möglichen Parameter erklärt. Zusätzlich werden noch einige andere Informationen, wie Kontaktmöglichkeiten, angezeigt.

\item[-o, -{}-output-file FILE]
  ermöglicht die Umlenkung der Ausgabe der \mic{} (nicht des \md{}) in eine Datei. Normalerweise wird die Ausgabe der \mic{} auf der Konsole ausgegeben.

  Mit dem Argument \texttt{FILE} wird hier der Pfad zur Datei gegeben, in die die Ausgabe geschrieben werden soll. Wenn die Datei bereits existiert, wird die Ausgabe an das Ende der Datei angehängt.

  Unter Linux kann man dann in einer zweiten Konsole diese Datei beispielsweise mit \texttt{tail -f} anzeigen und die Ausgabe der \mic{} komfortabel von der Ausgabe des \md{} trennen. In diesem Szenario ist auch der Parameter \texttt{-{}-unbuffered-output} sinnvoll.
\item[-u, -{}-unbuffered-output]
  verhindert die Pufferung der Ausgabe der \mic{}. Normalerweise gibt der \md{} die Ausgabe der \mic{} zeilenweise aus, also erst bei der Ausgabe eines Zeilenumbruchs. Verwendet man den Parameter \texttt{-{}-output-file} oder möchte man aus sonstigen Gründen jedes ausgegebene Zeichen der \mic{} direkt auf der Konsole sehen, so ist dieser Parameter die Lösung.

  \emph{Vorsicht!} Wird dieser Parameter ohne \texttt{-{}-output-file} genutzt, so kann es sehr schwer werden, die ausgegebenen Zeichen der \mic{} ausfindig zu machen, da sie womöglich in der Menge der Ausgaben von \md{} untergehen.

\item[-v, -{}-version]
  gibt die Version des \md{} aus.
\end{description}

Wenn einer der Parameter \texttt{-{}-help} oder \texttt{-{}-version} angegeben wurden, so startet der Debugger nicht. Dies kann genutzt werden, um ohne vorhandene Bytecode-Dateien Informationen über den \md{} anzeigen zu können. \lstref{aufrufe-ohne-start} zeigt, dass der \md{} daher auch ohne Bytecode-Dateien aufgerufen werden kann.

\begin{lstlisting}[language=sh,caption={Aufruf des \md{} ohne Start -- Konsolenversion},label=\lstlbl{aufrufe-ohne-start}]
  micro-debug.sh --help
  micro-debug.sh --version
\end{lstlisting}

Bei der Abarbeitung der gegebenen Parameter hängt die Reihenfolge der Parameter nicht von der Reihenfolge ab, in der sie dem \md{} als Parameter übergeben wurden. Wichtig ist nur, dass die beiden Bytecode-Dateien die letzten beiden Parameter und in der richtigen Reihenfolge aufgeführt sind.

\section{Befehle}
Ist der \md{} gestartet lässt er sich durch verschiedene Befehle steuern, die am Ende dieses Abschnitt ausführlich beschrieben werden.

Bei der Bedienung des \md{} gibt es die Möglichkeit, dass zwischen den verschiedenen Befehlen auch Eingaben für die \mic{} zu liefern sind. Damit der Benutzer sieht, ob die Eingabe vom \md{} oder der \mic{} erwartet wird, schreibt der \md{} '\texttt{micro-debug> }' und die \mic{} '\texttt{mic1> }' bevor eine Eingabe erwartet wird. Wenn die \mic{} eine Eingabe von Dir erwartet, kannst du mehrere Zeichen auf einmal eingeben -- an die \mic{} werden die von dir eingegebenen Zeichen plus ein Zeilenumbruch gesendet. Sollte dein Assembler-Code also in einer Schleife einzelne Zeichen einlesen, solltest du die gesamte Zeile direkt eingeben.

Die verschiedenen Befehle können ein oder mehrere Argumente benötigen. Die Argumente können einem der folgenden Datentypen gehören:
\begin{description}
\item[Register] ist der Name eines Registers, also \reg{CPP}, \reg{H}, \reg{LV}, \reg{MAR}, \reg{MBR}, \reg{MBRU}, \reg{MDR}, \reg{OPC}, \reg{PC}, \reg{SP} oder \reg{TOS}.
\item[Zahl] ist eine Zahl im Wertebereich eines Integers\notiz{Verweis?}. Die Formate für die Eingabe der Zahl sind in \secref{zahlenformat} beschrieben.
\end{description}

Je nach Befehl kann der zulässige Wertebereich jedoch noch weiter eingeschränkt sein -- eine solche Einschränkung ergibt sich aus der Beschreibung des jeweiligen Befehls.

\begin{description}
\item[break] \emph{Register [Zahl]}

  setzt einen Breakpoint für das gegebene \emph{Register}: Sobald das Register den Wert \emph{Zahl} erhält, hält der \md{}. Der \md{} hält erst, nachdem das Register den Wert erhalten hat -- da dies unter Umständen zu spät ist, gibt es die Möglichkeit, das Argument \emph{Zahl} wegzulassen. Wird nur ein Register angegeben, hält der \md{} bevor das Register einen neuen Wert zugewiesen bekommt.

\item[exit] \hspace*{\fill}\\

  beendet den \md{} und gibt eventuell belegte Ressourcen wieder frei.

\item[help] \hspace*{\fill}\\

  zeigt die verfügbaren Befehle mit einer kurzen Beschreibung an. Auch hier sind noch einige weitere Informationen über das Projekt enthalten.

\item[ls-break] \hspace*{\fill}\\

  zeigt alle Breakpoints mit deren jeweiligen Bedingung an. Jeder Breakpoint erhält eine Identifikationsnummer, die bei anderen Operationen, wie dem Entfernen, angegeben werden müssen.

\item[ls-macro-code] \emph{[Zahl1 [Zahl2]]}

  zeigt den disassemblierten Assembler-Code an. Dabei gibt es drei mögliche Konstellationen der Parameter:
  \begin{itemize}
  \item Wird kein Parameter gegeben, wird der vollständige Assembler-Code angezeigt.
  \item Wird ein Parameter \emph{Zahl1} gegeben, wird die angegebene Anzahl an Zeilen vor und nach der nächsten auszuführenden Codezeile angezeigt.
  \item werden beide Parameter gegeben, wird der Assembler-Code von Zeile \emph{Zahl1} bis zur Zeile \emph{Zahl2} (inklusive) angezeigt.
  \end{itemize}

  Da der \md{} nur den Bytecode kennt, gibt es eigentlich keine Zeilen. Der \md{} schreibt pro Zeile einen Befehl (inklusive Argumente), somit existieren Zeilennummern, die für den \md{} als Referenz dienen.

\item[ls-micro-code] \emph{[Zahl1 [Zahl2]]}

  zeigt den disassemblierten Mikro-Assembler-Code an und arbeitet wie \texttt{ls-macro-code}. Es gibt drei mögliche Konstellationen der Parameter:
  \begin{itemize}
  \item Wird kein Parameter gegeben, wird der vollständige Mikro-Assembler-Code angezeigt.
  \item Wird ein Parameter \emph{Zahl1} gegeben, wird die angegebene Anzahl an Zeilen vor und nach der nächsten auszuführenden Codezeile angezeigt.
  \item werden beide Parameter gegeben, wird der Mikro-Assembler-Code von Zeile \emph{Zahl1} bis zur Zeile \emph{Zahl2} (inklusive) angezeigt.
  \end{itemize}

  Da der \md{} nur den Bytecode kennt, gibt es eigentlich keine Zeilen. Der \md{} schreibt pro Zeile eine Mikroinstruktion (die $36~Bit$, die die Instruktion spezifizieren), somit existieren Zeilennummern, die für den \md{} als Referenz dienen.

\item[ls-mem] \emph{Zahl1 Zahl2}

  zeigt den Inhalt des Hauptspeichers zwischen den Adressen (inklusive) \emph{Zahl1} und \emph{Zahl2} an. Die Adressen des Speichers sind Wortadressen -- jedes Wort enthält $32~Bit$.

\item[ls-reg] \emph{[Register]}

  zeigt den Wert von dem gegebenen \emph{Register} an; wird das optionale Argument weggelassen, werden alle Register und deren Werte angezeigt.

\item[ls-stack] \hspace*{\fill}\\

  zeigt den aktuellen Stack an.

  \emph{Hinweis:} Dieser Befehl wird durch die Konfigurationsoption \texttt{stack.elements.to.hide} beeinflusst. Normalerweise wird der Stack von dem initialen Stackpointer bis zum aktuellen Stackpointer ausgegeben. Da dies unter Umständen mehr Elemente liefert, als der Stack tatsächlich enthält, gibt es die Möglichkeit über die Konfiguration die ersten Elemente nicht auszugeben.

Möchte man den realen (im Speicher vorhandenen) Stack sehen, sollte man sicherstellen, dass \texttt{stack.elements.to.hide = 0} konfiguriert ist.

\item[macro-break] \emph{Zahl}

  fügt einen Breakpoint hinzu, der den \md{} anhält, sobald der Bytecode des Assemblers an der Adresse \emph{Zahl} ausgeführt werden soll. \emph{Adresse} muss Element aus der Menge der von \texttt{ls-macro-code} angezeigten Zeilennummern sein.

\item[micro-break] \emph{Zahl}

  fügt einen Breakpoint hinzu, der den \md{} anhält, sobald der Bytecode des Mikro-Assemblers an der Adresse \emph{Zahl} ausgeführt werden soll. \emph{Adresse} muss Element aus der Menge der von \texttt{ls-micro-code} angezeigten Zeilennummern sein.

\item[micro-step] \emph{[Zahl]}

  führt die nächsten \emph{Zahl} Mikro-Instruktionen aus; wird kein Argument gegeben, so wird eine Instruktion ausgeführt.

\item[reset] \hspace*{\fill}\\

  die \mic{} wird in den Anfangszustand zurückgesetzt: Der Hauptspeicher und die Register werden auf die initialen Werte zurückgesetzt. Auch die Ein- und Ausgabe der \mic{} wird geleert. Die Informationen des \md{}, vor allem die Breakpoints, bleiben allerdings erhalten und müssen vom Benutzer nicht erneut gesetzt werden.

\item[rm-break] \emph{Zahl}

  entfernt den Breakpoint mit der Nummer \emph{Zahl}. Die Nummer des Breakpoints ist die Identifikationsnummer, die mit \texttt{ls-break} angezeigt wird.

\item[run] \hspace*{\fill}\\
  
  führt alle Instruktionen bis zum Programmende oder bis zum nächsten Breakpoint aus.

  \emph{Hinweis:} Unter Umständen und ungünstigem Programmcode kann das zu debuggende Programm in eine Schleife geraten, welche ohne Breakpoints nur durch den Programmabbruch beendet werden kann.

\item[set] \emph{Register Zahl}

  weist dem \emph{Register} den Wert \emph{Zahl} zu.

\item[set-mem] \emph{Zahl1 Zahl2}

  schreibt den Wert \emph{Zahl2} an die Wortadresse \emph{Zahl1} im Hauptspeicher.

  \emph{Hinweis:} Auch wenn dieser Befehl offensichtlich dazu genutzt werden könnte den Assembler-Code zu manipulieren, ist er für diesen Zweck nicht vorgesehen.

\item[step] \emph{[Zahl]}

  führt die nächsten \emph{Zahl} Instruktionen aus; wird kein Argument gegeben, so wird eine Instruktion ausgeführt.

\item[trace-mac] \hspace*{\fill}\\
  
  der Assembler-Code wird nun beobachtet. Dadurch wird jede Assembler-Instruktion angezeigt, nachdem sie ausgeführt wurde.

\item[trace-mic] \hspace*{\fill}\\

  der Mikro-Assembler-Code wird nun beobachtet. Dadurch wird jede Mikro-Assembler-Instruktion angezeigt, nachdem sie ausgeführt wurde.

\item[trace-reg] \emph{[Register]}

  das gegebene \emph{Register} wird nun beobachtet. Dadurch wird der Wert des Registers angezeigt, wenn er sich ändert. Wird das optionale Argument weggelassen, werden alle \emph{Register} beobachtet.

\item[trace-var] \emph{Zahl}

  die Variable \emph{Zahl} wird nun beobachtet. Dadurch wird der Inhalt der Variable angezeigt, wenn er sich ändert.

  \emph{Zahl} ist die Nummer der lokalen Variable. Wird eine Methode im Assembler-Code aufgerufen, ändert sich der Zeiger \reg{LV} und damit auch die Identität der lokalen Variablen. Wird also Variable Nummer~1 in Methode X beobachtet und führt der \md{} gerade Methode Y aus, wird eine Änderung der jetzigen lokalen Variable~1 nicht ausgegeben (sofern diese nicht auch beobachtet wird).

\item[untrace-mac] \hspace*{\fill}\\
  
  beendet das Beobachten des Assembler-Codes. Dadurch werden ausgeführte Assembler-Instruktionen nun nicht mehr ausgegeben.

\item[untrace-mic] \hspace*{\fill}\\

  beendet das Beobachten des Mikro-Assembler-Codes. Dadurch werden ausgeführte Mikro-Assembler-Instruktionen nun nicht mehr ausgegeben.

\item[untrace-reg] \emph{[Register]}

  beendet das Beobachten des gegebenen \emph{Register}s. Wird das optionale Argument weggelassen, wird nun kein Register mehr beobachtet.

\item[untrace-var] \emph{Zahl}

  beendet das Beobachten der lokalen Variable Nummer \emph{Zahl}.
\end{description}

\section{Tutorial}
Du solltest den \md{}, wie zu Beginn dieses Kapitels beschrieben, nun entpackt haben und am besten schon der \texttt{PATH}-Variable hinzugefügt haben. Denn dann kannst du in einem Verzeichnis deiner Wahl die Dateien für dieses Tutorial anlegen.

Wir möchten nun ein kleines Programm schreiben und dies testen: ein Programm zum Einlesen von Binärzahlen. \lstref{binary-read-c} zeigt den Code für das Programm in C\notiz{C referenz? erklärn?} und soll hier als Verständnis des Algorithmuses dienen.

\begin{lstlisting}[language=c,caption={C-Programm zum Einlesen einer Binärzahl},label=\lstlbl{binary-read-c}]
int main() {
  int character = 0;
  int result = 0;
  while(1) {
    character = getchar();
    if( c == '\n' ) {
      return result;
    }
    c = c - '0';
    result = 2 * result + c;
  }
}
\end{lstlisting}

Das entsprechende Assembler-Programm findest Du in \lstref{binary-read-jas}. Dieses Programm solltest du nun kompilieren -- \emph{Ray Ontko} stellt dafür in \cite{Ontko1999} einige Programme bereit: \texttt{mic1asm} zum Kompilieren des Mikro-Assembler-Codes und \texttt{ijvmasm} zum Kompilieren des Assembler-Codes. In \cite{Ontko1999} findest du auch den Mikro-Assembler-Code und eine entsprechende \texttt{ijvm.conf}-Datei.

\begin{lstlisting}[language=,caption={IJVM-Assembler zum Einlesen einer Binärzahl},label=\lstlbl{binary-read-jas}]
.main
.var
    c
    result
.end-var
    bipush      0
    istore      result
loop:
    in
    istore      c
    iload       c
    bipush      10
    if_icmpeq   finish
    iinc        c       -48(*@\srclbl{iinc-increment-value}@*)
    iload       result
    dup
    iadd
    iload       c
    iadd
    goto        loop
finish:
    iload       result
    halt
.end-main
\end{lstlisting}

Zum Debuggen des Mikro-Assembler-Codes und Assembler-Codes solltest Du die \texttt{ijvm.conf}-Datei verwenden, die Du zum Kompilieren der \datei{mic1} genutzt hast. Diese \date{conf} kannst Du entweder in das \texttt{conf/} Verzeichnis des Debuggers legen, oder jeweils in dem Verzeichnis, in dem Du gerade arbeitest. Dass Du nicht die korrekte \texttt{ijvm.conf}-Datei verwendest, siehst Du beim Ausführen des Befehls \texttt{ls-macro-code} -- zeigt dieser unbekannte Assembler-Befehle, enthält der Assembler-Code Befehle, die in der \texttt{ijvm.conf} nicht oder nicht an dieser Adresse definiert sind.

Bevor wir nun beginnen solltest Du auch die Konfigurationsoption \texttt{mic1.micro.address.ijvm} überprüfen. Diese Option enthält die Adresse der Mikro-Instruktion, die von allen Mikro-Code-Methoden angesprungen wird, um die nächste Mikro-Instruktion zu \emph{laden}. Ist diese Option falsch konfiguriert, funktioniert später der Befehl \texttt{step} nicht wie erwartet.

Die in \lstref{binary-read-jas} aufgeführte Methode soll später eine eigene Methode werden und gibt daher keinen Wert aus, sondern legt das Ergebnis am Ende auf den Stack. \lstref{tutorial-start} zeigt in \srcref{tutorial-startbefehl} den Befehl, um den \md{} zu starten -- im aktuellen Verzeichnis liegen die Dateien \texttt{mic1ijvm.mic1}, \texttt{binary-read.ijvm} und \texttt{ijvm.conf}.

\begin{lstlisting}[language=,caption={Start des \md{}},label=\lstlbl{tutorial-start}]
micro-debug.sh mic1ijvm.mic1 binary-read.ijvm(*@\srclbl{tutorial-startbefehl}@*)
MicroDebug - Copyright (C) 2011-2012 Christian Roesch AND 1999 Prentice-Hall, Inc. (*@\srclbl{tutorial-start-willkommen}@*)
Welcome! Please type 'help' for a list of valid commands
----------------------------------------
micro-debug> (*@\srclbl{tutorial-start-mdread}@*)
\end{lstlisting}

Ab \srcref{tutorial-start-willkommen} steht die Willkommensnachricht des \md{} gefolgt von der \srcref{tutorial-start-mdread}, die anzeigt, dass der \md{} nun einen Befehl erwartet. Wir können uns nun eine ausführliche Beschreibung der verschiedenen Befehle anzeigen, mit dem Befehl \texttt{help}.

Geben wir den Befehl \texttt{ls-macro-code} ein, erhalten wir den disassemblierten Assembler-Code, wie in \lstref{tutorial-macro-code} zu sehen. Die Ausgabe zeigt zunächst pro Zeile die Assembler-Code-Zeile, dann die Adresse des Befehls im Mikro-Assembler-Code und anschließend den Namen des Befehls mit seinen Argumenten. Die Ausgabe ist nicht identisch mit dem Code, den wir anfangs kompiliert haben -- in \lstref{binary-read-jas} -- in der disassemblierten Variante fehlen Informationen wie Kommentare, Variablennamen und Sprungmarkennamen. Beispielsweise zeigt \srcref{tutorial-macro-code-sprung} einen bedingten Sprung zur Zeile \texttt{0x1B}.

\begin{lstlisting}[language=,caption={Disassemblierter Assembler-Code},label=\lstlbl{tutorial-macro-code}]
     0x0: [ 0x10] BIPUSH  0x0
     0x2: [ 0x36] ISTORE  1
(*@\srclbl{tutorial-macro-code-in}@*)     0x4: [ 0xFC] IN 
     0x5: [ 0x36] ISTORE  0(*@\srclbl{tutorial-macro-code-after-in}@*)
     0x7: [ 0x15] ILOAD  0
     0x9: [ 0x10] BIPUSH  0xA
(*@\srclbl{tutorial-macro-code-sprung}@*)     0xB: [ 0x9F] IF_ICMPEQ  0x1B
     0xE: [ 0x84] IINC  0 0x0(*@\footnote{Der \md{} hat an dieser Stelle einen Bug: Wie in \srcref{iinc-increment-value} in \lstref{binary-read-jas} zu sehen, ist der Wert \texttt{0} falsch. Unter \url{https://github.com/croesch/micro-debug/issues/37} ist die entsprechende Dokumentation zu dem Bug. Dieser Bug hat allerdings keine Auswirkung auf die Funktionsweise der \mic{}, sondern nur auf das Disassemblen des Assembler-Codes -- also der Ausgabe des \md{}.}@*)
    0x11: [ 0x15] ILOAD  1
    0x13: [ 0x59] DUP 
    0x14: [ 0x60] IADD 
    0x15: [ 0x15] ILOAD  0
    0x17: [ 0x60] IADD 
    0x18: [ 0xA7] GOTO  0x4
    0x1B: [ 0x15] ILOAD  1
    0x1D: [ 0xFF] HALT 
\end{lstlisting}

Das erwartete Ergebnis eines Programmlaufs ist, dass wir die eingegebene Binärzahl am Ende auf dem Stack und damit im Register \reg{TOS} vorfinden -- geben wir $1010$ ein, soll \reg{TOS} nach einem Programmdurchlauf den Wert $10$ enthalten.

Mit dem Befehl \texttt{run} lassen wir das Programm nun zunächst ohne Breakpoints laufen. Nachdem wir das Programm gestartet haben, wird die \mic{} in \srcref{tutorial-macro-code-in} aus \lstref{tutorial-macro-code} mit dem Befehl \texttt{IN} Zeichen einlesen. Das erkennst Du auf der Konsole an der \srcref{tutorial-mic-eingabe-txt} aus \lstref{tutorial-mic-eingabe} -- statt \texttt{micro-debug>} steht hier nun \texttt{mic1>}.

\begin{lstlisting}[language=,caption={\mic{} erwartet Eingabe},label=\lstlbl{tutorial-mic-eingabe}]
micro-debug> run
mic1> (*@\srclbl{tutorial-mic-eingabe-txt}@*)
\end{lstlisting}

Wir geben nun \texttt{1010} ein und bestätigen die Eingabe mit \texttt{ENTER} -- dadurch werden fünf Zeichen im \md{} gepuffert: Die vier Zeichen, die wir eingegeben haben plus ein Zeilenumbruch. Jedes Mal, wenn die \mic{} nun ein Zeichen benötigt, wird aus diesem Puffer gelesen. Erst wenn dieser leer ist, erscheint erneut die Eingabeaufforderung für den Benutzer.

\begin{lstlisting}[language=,caption={\md{} gibt Anzahl ausgeführter Zyklen aus},label=\lstlbl{tutorial-durchgelaufen}]
Processor executed 441 ticks.
micro-debug> 
\end{lstlisting}

Nachdem wir nun die Zahl eingegeben haben erscheint die Ausgabe aus \lstref{tutorial-durchgelaufen}, die uns anzeigt, dass die \mic{} insgesamt $441$ Zyklen ausgeführt hat. Da unser Programm keine Ausgabe macht, sondern das Ergebnis auf den Stack (und damit in dem Register \reg{TOS}) ablegt, überprüfen wir das nun wie folgt. Mit dem Befehl \texttt{ls-reg} lassen wir uns wie in \lstref{tutorial-tos-falscher-wert} zu sehen den Inhalt des Registers \reg{TOS} anzeigen.

Das Register \reg{TOS} enthält den Wert $0$ und damit einen falschen Wert. Wir können nun noch den Stack anzeigen, um zu überprüfen, ob dort der erwartete Wert $10$ abgelegt ist. Den Stack zeigen wir mit dem Befehl \texttt{ls-stack} an, was die in \lstref{tutorial-stack} gezeigte Ausgabe liefert.

\begin{lstlisting}[language=,caption={\md{} gibt Anzahl ausgeführter Zyklen aus},label=\lstlbl{tutorial-tos-falscher-wert}]
micro-debug> ls-reg TOS
Register TOS : 0x0
micro-debug> 
\end{lstlisting}

Der erwartete Wert $10$ liegt auch nicht auf dem Stack. Wäre der Wert auf dem Stack, aber nicht im Register \reg{TOS} wäre das ein Hinweis auf einen Fehler im Mikro-Assembler-Code, da dieser für die Einhaltung der Regel zuständig ist, dass das Register \reg{TOS} stets den Wert des obersten Elements des Stacks enthält.

\begin{lstlisting}[language=,caption={Inhalt des Stacks nach der Ausführung des Assembler-Programms},label=\lstlbl{tutorial-stack}]
Stack value #1 [  0xC001]: 0x1
Stack value #2 [  0xC002]: 0x0
Stack value #3 [  0xC003]: 0x1
Stack value #4 [  0xC004]: 0x0
Stack value #5 [  0xC005]: 0x0
micro-debug> 
\end{lstlisting}

Damit wir das Programm erneut ablaufen lassen können, müssen wir die \mic{} auf ihren Startzustand zurücksetzen; mit dem Befehl \texttt{reset}. Woran könnte das Problem liegen? Womöglich werden falsche Werte eingelesen; mit einem Breakpoint auf dem \texttt{IN}-Befehl überprüfen wir diese Vermutung. In \lstref{tutorial-breakpoint-mac} ist aufgeführt, wie wir einen Breakpoint in der Zeile \texttt{0x4} setzen können und überprüfen, welche Breakpoints gesetzt sind.

\begin{lstlisting}[language=,caption={Setzen eines Breakpoints im Assembler-Code},label=\lstlbl{tutorial-breakpoint-mac}]
micro-debug> macro-break 4
micro-debug> ls-break
Breakpoint #1: at macro code line 0x4
micro-debug> 
\end{lstlisting}

Nachdem wir den Breakpoint nun gesetzt haben, können wir das Programm mit dem Befehl \texttt{run} ausführen. An der Ausgabe erkennen wir, dass die \mic{} nicht das gesamte Programm ausgeführt hat, sondern nur 16~Zyklen. Wir werden nun den \texttt{IN}-Befehl überprüfen und dazu einzeln die Mikro-Instruktionen des Befehls ausführen. Damit wir nicht jedes Mal den Mikro-Assembler-Code anzeigen lassen müssen, beobachten wir den Mikro-Assembler-Code mit dem Befehl \texttt{trace-mic}.

Je nach Mikro-Assembler-Code kann es mehrere Mikro-Instruktionen dauern, bis wir zu dem \texttt{IN}-Befehl kommen. Wichtig ist die Zeile, die \texttt{goto (MBR)} ausführt -- daher führen wir nun so lange den Befehl \texttt{micro-step} aus, bis dieser Sprungbefehl ausgeführt wurde. Bei mir wurden von der Stelle, an der der Debugger gehalten hat, bis zu dem Sprungbefehl drei Mikro-Instruktionen ausgeführt, wie in \lstref{tutorial-steps-to-goto} zu sehen ist.

\begin{lstlisting}[language=,caption={Ausgeführte Mikro-Instruktionen bis zum Sprungbefehl \texttt{goto (MBR)}},label=\lstlbl{tutorial-steps-to-goto}]
micro-debug> micro-step
Executed: fetch;goto 0x4
Processor executed 1 ticks.
micro-debug> micro-step
Executed: PC=PC+1;goto 0x5
Processor executed 1 ticks.
micro-debug> micro-step
Executed: goto (MBR)
Processor executed 1 ticks.
\end{lstlisting}

Bei meiner Implementierung liegt der Befehl \texttt{IN} an der Stelle \texttt{0xFC}. In \lstref{tutorial-in-micro} siehst du den Mikro-Assembler-Code für den Befehl \texttt{IN} -- bis zur Zeile \texttt{0x6B} wird die Adresse für \emph{memory mapped IO} erzeugt, -3. In Zeile \texttt{0x6B} (\srcref{tutorial-in-micro-rd} in \lstref{tutorial-in-micro}) wird der \texttt{rd}-Befehl ausgeführt.

\begin{lstlisting}[language=,caption={Mikro-Assembler-Code des Befehls \texttt{IN}},label=\lstlbl{tutorial-in-micro}]
0xFC: H=OPC=-1;goto 0x6A
0x6A: OPC=H+OPC;goto 0x6B
0x6B: MAR=H+OPC;rd;goto 0x6C(*@\srclbl{tutorial-in-micro-rd}@*)
0x6C: SP=MAR=SP+1;goto 0x6D
0x6D: TOS=MDR;wr;goto 0x3
\end{lstlisting}

Wir können nun in \lstref{tutorial-check-rd-mdr} sehen, wie wir die drei Mikro-Instruktionen zum Aufbau der Speicheradresse und zum Einlesen des Zeichens ausführen. Während der Ausführung fragt der \md{} im Auftrag der \mic{} nach einer Eingabe, hier geben wir wieder \texttt{1010} ein und bestätigen mit \texttt{ENTER}.

\begin{lstlisting}[language=,caption={Überprüfung des \texttt{rd}-Befehls durch den Inhalt des Registers \reg{MDR}},label=\lstlbl{tutorial-check-rd-mdr}]
micro-debug> micro-step 3
Executed: H=OPC=-1;goto 0x6A
Executed: OPC=H+OPC;goto 0x6B
mic1> 1010
Executed: MAR=H+OPC;rd;goto 0x6C
Processor executed 3 ticks.
micro-debug> micro-step 1(*@\srclbl{tutorial-check-rd-mdr-step}@*)
Executed: SP=MAR=SP+1;goto 0x6D
Processor executed 1 ticks.
micro-debug> ls-reg MDR(*@\srclbl{tutorial-check-rd-mdr-cont}@*)
Register MDR : 0x31
\end{lstlisting}

Die \mic{} hat nun Zeile \texttt{0x6B} ausgeführt und das erste Zeichen gelesen. Dieses Zeichen wird allerdings erst im nächsten Zyklus in das Register \reg{MDR} geschrieben -- daher sehen wir ab \srcref{tutorial-check-rd-mdr-step} die Ausführung einer weiteren Mikro-Instruktion. Jetzt muss das gelesene Zeichen im Register \reg{MDR} angekommen sein, was wir mit dem Befehl \texttt{ls-reg MDR} überprüfen. Wie ab Zeile \srcref{tutorial-check-rd-mdr-cont} zu sehen, enthält das Register \reg{MDR} den Wert $0x31=49$ -- der \emph{ASCII}-Code für das Zeichen \texttt{1}.

Der Fehler scheint nicht im Mikro-Assembler-Code zu liegen -- zumindest nicht, wo wir überprüft haben. Deswegen konzentrieren wir uns nun auf den Assembler-Code. Mit dem Befehl \texttt{step} führen wir die letzte Mikro-Instruktion des Befehls \texttt{IN} aus. Wir befinden uns nun in Zeile \texttt{0x5} des Assembler-Codes -- der \srcref{tutorial-macro-code-after-in} aus \lstref{tutorial-macro-code}.

Damit wir die Veränderungen der lokalen Variablen direkt erkennen, beobachten wir sie. In \lstref{binary-read-jas} können wir überprüfen, wie viele lokale Variablen wir haben: zwei. Wir beobachten gleich beide, um zu sehen, ob der \emph{ASCII}-Code korrekt konvertiert wird und welche Werte das Ergebnis annimmt. In \lstref{tutorial-watch-vars} ist zu sehen, wie wir dazu den Befehl \texttt{trace-var} nutzen.

\begin{lstlisting}[language=,caption={Beobachten beider lokaler Variablen},label=\lstlbl{tutorial-watch-vars}]
micro-debug> trace-var 0
micro-debug> trace-var 1
\end{lstlisting}

Wir werden das Programm nun schrittweise ausführen -- da wir auf die Korrektheit des Mikro-Assembler-Codes vertrauen, führen wir jeweils Assembler-Instruktionen aus. Wir überprüfen dann, ob das erwartete Verhalten eingetreten ist und suchen so schrittweise die Ursache für den Fehler. Zur Erinnerung, wir haben gerade eine \texttt{1} eingelesen.

Mit dem Befehl \texttt{step} führen wir die nächste Assembler-Instruktion aus. In \lstref{tutorial-step-trace-mic} ist die Ausgabe dieses Befehls zu sehen -- da wir den Mikro-Assembler-Code noch beobachten ist diese Ausgabe unübersichtlich. Wir können aber in \srcref{tutorial-step-trace-mic-varwrite} sehen, dass die lokale Variable \texttt{0} den korrekten Wert erhalten hat.

\begin{lstlisting}[language=,caption={Ausführen einer Assembler-Instruktion bei Beobachten des Mikro-Assembler-Codes},label=\lstlbl{tutorial-step-trace-mic}]
micro-debug> step
Executed: fetch;goto 0x4
Executed: PC=PC+1;goto 0x5
Executed: goto (MBR)
Executed: H=LV;fetch;goto 0x1F
Executed: MDR=TOS;goto 0x20
Executed: MAR=H+MBRU;wr;goto 0x21
Local variable 0: 49(*@\srclbl{tutorial-step-trace-mic-varwrite}@*)
Executed: SP=MAR=SP-1;rd;goto 0x22
Executed: PC=PC+1;goto 0x23
Executed: TOS=MDR;goto 0x3
Processor executed 9 ticks.
\end{lstlisting}

Damit wir im Folgenden übersichtlichere Ausgaben erhalten, beenden wir das Beobachten des Mikro-Assembler-Codes durch den Befehl \texttt{untrace-mic}. Zusätzlich Beobachten wir nun den Assembler-Code, um bei jeder ausgeführten Instruktion überprüfen zu können, was gerade ausgeführt wurde. Nachdem wir den Befehl \texttt{trace-mac} können wir das Programm weiter schrittweise ausführen.

\begin{lstlisting}[language=,caption={Ausführen der Assembler-Instruktionen zum Vergleich zweier lokaler Variablen},label=\lstlbl{tutorial-check-var}]
micro-debug> step
Executed:      0x7: [ 0x15] ILOAD  0
Processor executed 8 ticks.
micro-debug> ls-stack
Stack value #1 [  0xC001]: 0x31
micro-debug> step
Executed:      0x9: [ 0x10] BIPUSH  0xA
Processor executed 6 ticks.
micro-debug> ls-stack
Stack value #1 [  0xC001]: 0x31
Stack value #2 [  0xC002]: 0xA
micro-debug> step
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1B
Processor executed 11 ticks.
micro-debug> ls-stack
Stack doesn't contain any elements, nothing to display.(*@\srclbl{tutorial-check-var-stack-empty}@*)
\end{lstlisting}

\lstref{tutorial-check-var} enthält die Konsolenausgabe nach der Ausführung der nächsten drei Assembler-Instruktionen. Da diese Instruktionen auf dem Stack operieren, habe ich zusätzlich nach jedem Befehl den Stack angezeigt. Das Programm prüft hier, ob die eingegebene Zahl ein Zeilenumbruch ist. Dafür legt es die eingegebene Zahl und einen Zeilenumbruch auf den Stack und ruft die Instruktion \texttt{IF_ICMPEQ} auf, die bei Gleichheit der beiden obersten Zahlen auf dem Stack an die angegebene Adresse springt.

An den Konsolenausgaben können wir erkennen, dass zunächst beide Zahlen korrekt auf den Stack gelegt werden. Der Vergleich sollte die beiden Werte vom Stack entfernen und sie dann vergleichen; in \srcref{tutorial-check-var-stack-empty} in \lstref{tutorial-check-var} sehen wir, dass der Stack korrekterweise keine Elemente enthält. Wenn wir nun die nächste Instruktion ausführen, können wir an der Adresse der Instruktion erkennen, dass der bedingte Sprung nicht ausgeführt wurde.

\begin{lstlisting}[language=,caption={Ausführen der Assembler-Instruktionen zur Berrechnung des temporären Ergebnisses},label=\lstlbl{tutorial-calc-temp-result}]
micro-debug> step
Executed:      0xE: [ 0x84] IINC  0 0x0
Local variable 0: 1
Processor executed 9 ticks.
micro-debug> step
Executed:     0x11: [ 0x15] ILOAD  1
Processor executed 8 ticks.
micro-debug> step
Executed:     0x13: [ 0x59] DUP 
Processor executed 5 ticks.
micro-debug> step
Executed:     0x14: [ 0x60] IADD 
Processor executed 6 ticks.
micro-debug> step
Executed:     0x15: [ 0x15] ILOAD  0
Processor executed 8 ticks.
micro-debug> step
Executed:     0x17: [ 0x60] IADD 
Processor executed 6 ticks.
micro-debug> ls-stack
Stack value #1 [  0xC001]: 0x1(*@\srclbl{tutorial-calc-temp-result-result}@*)
\end{lstlisting}

Stattdessen wurde nun der \emph{ASCII}-Code dekodiert und die lokale Variable enthält den Wert \texttt{1}\footnote{Auch hier ist die Ausgabe des \texttt{IINC}-Befehl inkorrekt. Dies ist der selbe Fehler, wie oben und hat nur Auswirkungen auf die Ausgabe, wie Du am korrekten Wert der lokalen Variable erkennen kannst.}. Im Folgenden wird das Programm das aktuelle Ergebnis -- das derzeit \texttt{0} ist -- mit zwei multiplizieren und die gerade gelesene Zahl dazu addieren.

\lstref{tutorial-calc-temp-result} zeigt die gerade beschriebenen Schritte. Zunächst wird das derzeitige Ergebnis geladen, auf dem Stack dupliziert und dann aufaddiert, was der Multiplikation mit zwei entspricht. Anschließend wird die gelesene Zahl auf den Stack gelegt und dazu addiert und sollte das aktuelle Ergebnis ergeben. Mit dem Befehl \texttt{ls-stack} können wir nun sehen, dass diese Annahme korrekt ist -- es liegt der Wert \texttt{1} auf dem Stack, wie in \srcref{tutorial-calc-temp-result-result} in \lstref{tutorial-calc-temp-result} zu sehen.

Bisher ist der Assembler-Code also scheinbar auch korrekt. In \lstref{tutorial-error-reason} kannst Du die Konsolenausgabe nach der Ausführung der nächsten Assembler-Instruktion sehen. Hier führt die \mic{} den \texttt{GOTO}-Befehl aus und springt zu Adresse \texttt{0x4}, an der der \texttt{IN}-Befehl liegt.

\begin{lstlisting}[language=,caption={Ausführen des fehlerhaften Schritts},label=\lstlbl{tutorial-error-reason}]
micro-debug> step
Executed:     0x18: [ 0xA7] GOTO  0x4
Processor executed 8 ticks.
\end{lstlisting}

Vermutlich liegt der Fehler des Programms darin, das berechnete Ergebnis nicht in der lokalen Variable zu speichern. Wenn diese Vermutung stimmt, sollte der Stack pro Schleifendurchlauf wachsen, da das Ergebnis am Ende der Schleife auf dem Stack liegt, aber nicht mehr gelesen wird. Dies lässt sich durch die Beobachtung aus \lstref{tutorial-stack} zumindest nicht widerlegen: der Stack enthielt am Ende des Programmlaufs viele Elemente.

Diese Vermutung soll nun näher überprüft werden. Dazu setzen wir noch einen Breakpoint auf Zeile \texttt{0x18} des Assembler-Codes, dem Schleifenende. Da die Zeile \texttt{0x4} unmittelbar nach der Zeile \texttt{0x18} ausgeführt wird, können wir den Breakpoint in Zeile \texttt{0x4} entfernen.

\begin{lstlisting}[language=,caption={Setzen eines Breakpoints und Beobachten der lokalen Variablen},label=\lstlbl{tutorial-trace-vars}]
micro-debug> macro-break 0x18
micro-debug> ls-break
Breakpoint #1: at macro code line 0x4
Breakpoint #2: at macro code line 0x18
micro-debug> trace-var 0(*@\srclbl{tutorial-trace-vars-v0}@*)
micro-debug> trace-var 1(*@\srclbl{tutorial-trace-vars-v1}@*)
micro-debug> rm-break 1
micro-debug> ls-break
Breakpoint #2: at macro code line 0x18
\end{lstlisting}

\lstref{tutorial-trace-vars} zeigt das Setzen des Breakpoints in Zeile \texttt{0x18} mit anschließender Anzeige aller Breakpoints. In \srcref{tutorial-trace-vars-v0} wird zusätzlich die lokale Variable \texttt{0} beobachtet, die das gelesene Zeichen enthält. Der Vermutung nach wird die lokale Variable \texttt{1}, die das Ergebnis enthalten sollte, nie beschrieben; Daher Beobachten wir auch diese in Zeile \srcref{tutorial-trace-vars-v1}.

Anschließend wird der alte Breakpoint aus Zeile \texttt{0x4} entfernt -- die Nummer, die dabei angegeben wird, ist die Nummer des Breakpoints den der Befehl \texttt{ls-break} liefert. Nachdem nun die verschiedenen Ausgaben gesetzt sind und ein neuer Breakpoint gesetzt ist, kann mit dem \texttt{RUN}-Befehl jeweils ein Schleifendurchlauf bis zum Ende des Programms ausgeführt werden.

\begin{lstlisting}[language=,caption={Schleifendurchlauf Nummer~2},label=\lstlbl{tutorial-loop-2}]
micro-debug> run
Executed:      0x4: [ 0xFC] IN 
Executed:      0x5: [ 0x36] ISTORE  0
Local variable 0: 48(*@\srclbl{tutorial-loop-2-48-in-0}@*)
Executed:      0x7: [ 0x15] ILOAD  0(*@\srclbl{tutorial-loop-2-check-if-lf}@*)
Executed:      0x9: [ 0x10] BIPUSH  0xA
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1B
Executed:      0xE: [ 0x84] IINC  0 0x0(*@\footnote{Bug \#37}@*)(*@\srclbl{tutorial-loop-2-48-to-0}@*)
Local variable 0: 0
Executed:     0x11: [ 0x15] ILOAD  1(*@\srclbl{tutorial-loop-2-calc-result}@*)
Executed:     0x13: [ 0x59] DUP 
Executed:     0x14: [ 0x60] IADD 
Executed:     0x15: [ 0x15] ILOAD  0
Executed:     0x17: [ 0x60] IADD 
Processor executed 84 ticks.
\end{lstlisting}

In \lstref{tutorial-loop-2} kannst Du die Konsolenausgabe beim nächsten -- dem zweiten -- Schleifendurchlauf sehen. In \srcref{tutorial-loop-2-48-in-0} kannst Du sehen, dass der Wert \texttt{48} korrekt der lokalen Variable \texttt{0} zugewiesen wird. Die \texttt{48} ist der \emph{ASCII}-Code für \texttt{0}, was das zweite Zeichen unserer Eingabe \texttt{1010} war.

Ab \srcref{tutorial-loop-2-check-if-lf} wird überprüft, ob das gelesene Zeichen ein Zeilenumbruch ist. Auch hier ist korrekt, dass ab \srclbl{tutorial-loop-2-48-to-0} das gelesene Zeichen in den Zahlenwert konvertiert wird und ab \srcref{tutorial-loop-2-calc-result} das Ergebnis berechnet wird.

\begin{lstlisting}[language=,caption={Stack nach Schleifendurchlauf Nummer~2},label=\lstlbl{tutorial-stack-after-loop-2}]
micro-debug> ls-stack
Stack value #1 [  0xC001]: 0x1
Stack value #2 [  0xC002]: 0x0
\end{lstlisting}

In \lstref{tutorial-stack-after-loop-2} ist der aktuelle Stack nach dem jetzigen zweiten Schleifendurchlauf zu sehen. Wie erwartet ist er um ein Element angewachsen, dass nun \texttt{0} ist. Da das Ergebnis nie in der lokalen Variable abgelegt wird, ist in der Schleife das alte Ergebnis \texttt{0}, welches zur Berechnung des aktuellen Ergebnisses verwendet wird. Wenn das bisherige Ergebnis \texttt{0} ist, dann entspricht das aktuelle Ergebnis gerade der gelesenen Zahl.

Aus der Vermutung über die Fehlerursache kann also geschlussfolgert werden, dass am Ende gerade die eingelesenen Ziffern auf dem Stack liegen müssten. Auch diese Schlussfolgerung konnte bereits in \lstref{tutorial-stack} beobachtet werden. Daher akzeptieren wir nun unsere Vermutung und korrigieren das Assembler-Programm; \lstref{binary-read-jas-correct} zeigt die korrigierte Version. Die Korrektur ist die eingefügte \srcref{binary-read-jas-corrected-line} -- das Speichern des aktuellen Ergebnisses in der lokalen Variable.

\begin{lstlisting}[language=,caption={IJVM-Assembler zum Einlesen einer Binärzahl (korrigiert)},label=\lstlbl{binary-read-jas-correct}]
.main
.var
    c
    result
.end-var
    bipush      0
    istore      result
loop:
    in
    istore      c
    iload       c
    bipush      10
    if_icmpeq   finish
    iinc        c       -48
    iload       result
    dup
    iadd
    iload       c
    iadd
    istore      result(*@\srclbl{binary-read-jas-corrected-line}@*)
    goto        loop
finish:
    iload       result
    halt
.end-main
\end{lstlisting}

Nachdem die korrigierte Version des Assembler-Codes kompiliert ist, können wir sie debuggen. Der \md{} kann den Mikro-Assembler-Code und Assembler-Code nicht automatisch aktualisieren und muss daher mit dem Befehl \texttt{EXIT} beendet werden. Anschließend kann er mit dem korrigierten Kompilat gestartet werden.

Mit dem Befehl \texttt{ls-macro-code} kann nun überprüft werden, ob der Assembler-Code korrekt aktualisiert wurde. In \lstref{tutorial-macro-code-correct} ist die Ausgabe des Befehls zu sehen -- \srcref{tutorial-macro-code-corrected-line} zeigt die neu eingefügte Zeile.

\begin{lstlisting}[language=,caption={Disassemblierter Assembler-Code (korrigiert)},label=\lstlbl{tutorial-macro-code-correct}]
micro-debug> ls-macro-code
     0x0: [ 0x10] BIPUSH  0x0
     0x2: [ 0x36] ISTORE  1
     0x4: [ 0xFC] IN 
     0x5: [ 0x36] ISTORE  0
     0x7: [ 0x15] ILOAD  0
     0x9: [ 0x10] BIPUSH  0xA
     0xB: [ 0x9F] IF_ICMPEQ  0x1D
     0xE: [ 0x84] IINC  0 0x0(*@\footnote{Bug \#37}@*)
    0x11: [ 0x15] ILOAD  1
    0x13: [ 0x59] DUP 
    0x14: [ 0x60] IADD 
    0x15: [ 0x15] ILOAD  0
    0x17: [ 0x60] IADD 
    0x18: [ 0x36] ISTORE  1(*@\srclbl{tutorial-macro-code-corrected-line}@*)
    0x1A: [ 0xA7] GOTO  0x4
    0x1D: [ 0x15] ILOAD  1
    0x1F: [ 0xFF] HALT 
\end{lstlisting}

Du hast nun überprüft, dass der Assembler-Code korrekt aktualisiert wurde, daher kannst Du jetzt überprüfen, ob die Vermutung korrekt war und der Fehler im Assembler-Code nun behoben ist. Beim Beenden des \md{} werden Breakpoints sowie beobachtete Register, Variablen oder Assembler-Code verworfen -- zur leichteren Übersicht kannst Du diese daher nochmal aktivieren.

\begin{lstlisting}[language=,caption={Beobachten des Assembler-Codes und der lokalen Variablen},label=\lstlbl{tutorial-watch-code-vars}]
micro-debug> trace-mac
micro-debug> trace-var 0
micro-debug> trace-var 1
\end{lstlisting}

Diese Befehle, um das Beobachten wieder zu aktivieren sind in \lstref{tutorial-watch-code-vars} aufgeführt. Ein Breakpoint wirst Du jetzt nicht mehr benötigen; führe das Programm aus und analysiere die Ausgaben. \lstref{tutorial-output-of-correct-1} und \lstref{tutorial-output-of-correct-2} enthalten die Konsolenausgaben bei der Ausführung des Assembler-Codes; wieder wurde \texttt{1010} eingegeben.

\begin{lstlisting}[language=,caption={Konsolenausgabe der Ausführung des korrekten Assembler-Codes -- Teil~1},label=\lstlbl{tutorial-output-of-correct-1}]
micro-debug> run
Executed:      0x0: [ 0x10] BIPUSH  0x0
Executed:      0x2: [ 0x36] ISTORE  1
Executed:      0x4: [ 0xFC] IN 
mic1> 1010
Executed:      0x5: [ 0x36] ISTORE  0
Local variable 0: 49
Executed:      0x7: [ 0x15] ILOAD  0
Executed:      0x9: [ 0x10] BIPUSH  0xA
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1D
Executed:      0xE: [ 0x84] IINC  0 0x0
Local variable 0: 1
Executed:     0x11: [ 0x15] ILOAD  1
Executed:     0x13: [ 0x59] DUP 
Executed:     0x14: [ 0x60] IADD 
Executed:     0x15: [ 0x15] ILOAD  0
Executed:     0x17: [ 0x60] IADD 
Executed:     0x18: [ 0x36] ISTORE  1
Local variable 1: 1
Executed:     0x1A: [ 0xA7] GOTO  0x4
Executed:      0x4: [ 0xFC] IN 
Executed:      0x5: [ 0x36] ISTORE  0
Local variable 0: 48
Executed:      0x7: [ 0x15] ILOAD  0
Executed:      0x9: [ 0x10] BIPUSH  0xA
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1D
Executed:      0xE: [ 0x84] IINC  0 0x0
Local variable 0: 0
Executed:     0x11: [ 0x15] ILOAD  1
Executed:     0x13: [ 0x59] DUP 
Executed:     0x14: [ 0x60] IADD 
Executed:     0x15: [ 0x15] ILOAD  0
Executed:     0x17: [ 0x60] IADD 
Executed:     0x18: [ 0x36] ISTORE  1
Local variable 1: 2
Executed:     0x1A: [ 0xA7] GOTO  0x4
Executed:      0x4: [ 0xFC] IN 
Executed:      0x5: [ 0x36] ISTORE  0
Local variable 0: 49
Executed:      0x7: [ 0x15] ILOAD  0
Executed:      0x9: [ 0x10] BIPUSH  0xA
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1D
Executed:      0xE: [ 0x84] IINC  0 0x0
Local variable 0: 1
Executed:     0x11: [ 0x15] ILOAD  1
Executed:     0x13: [ 0x59] DUP 
Executed:     0x14: [ 0x60] IADD 
Executed:     0x15: [ 0x15] ILOAD  0
Executed:     0x17: [ 0x60] IADD 
Executed:     0x18: [ 0x36] ISTORE  1
Local variable 1: 5
Executed:     0x1A: [ 0xA7] GOTO  0x4
\end{lstlisting}

Wie Du sicherlich bemerkt hast, ist das Assembler-Programm nun korrekt: Der Stack und das Register \reg{TOS} enthalten am Ende das Ergebnis -- \texttt{0xA}.

\begin{lstlisting}[language=,caption={Konsolenausgabe der Ausführung des korrekten Assembler-Codes -- Teil~2},label=\lstlbl{tutorial-output-of-correct-2}]
Executed:      0x4: [ 0xFC] IN 
Executed:      0x5: [ 0x36] ISTORE  0
Local variable 0: 48
Executed:      0x7: [ 0x15] ILOAD  0
Executed:      0x9: [ 0x10] BIPUSH  0xA
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1D
Executed:      0xE: [ 0x84] IINC  0 0x0
Local variable 0: 0
Executed:     0x11: [ 0x15] ILOAD  1
Executed:     0x13: [ 0x59] DUP 
Executed:     0x14: [ 0x60] IADD 
Executed:     0x15: [ 0x15] ILOAD  0
Executed:     0x17: [ 0x60] IADD 
Executed:     0x18: [ 0x36] ISTORE  1
Local variable 1: 10
Executed:     0x1A: [ 0xA7] GOTO  0x4
Executed:      0x4: [ 0xFC] IN 
Executed:      0x5: [ 0x36] ISTORE  0
Local variable 0: 10
Executed:      0x7: [ 0x15] ILOAD  0
Executed:      0x9: [ 0x10] BIPUSH  0xA
Executed:      0xB: [ 0x9F] IF_ICMPEQ  0x1D
Executed:     0x1D: [ 0x15] ILOAD  1
Executed:     0x1F: [ 0xFF] HALT 
Processor executed 477 ticks.
micro-debug> ls-stack
Stack value #1 [  0xC001]: 0xA
micro-debug> ls-reg TOS
Register TOS : 0xA
\end{lstlisting}
