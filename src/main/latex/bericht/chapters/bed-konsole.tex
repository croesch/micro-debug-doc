\chapter{Interaktion per Konsole}
\label{bed-konsole}
Wie in Kapitel \ref{allgemein} beschrieben, muss der \md{} nicht installiert werden: Vom Herunterladen bis zum Starten des \md{} genügen folgende Schritte.

\begin{enumerate}
\item Die Datei \texttt{micro-debug-version.zip} von der Projektseite\notiz{Verweis auf Seite} herunterladen
\item Die \datei{zip} in ein beliebiges Verzeichnis entpacken (bspw. \texttt{/opt/micro-debug/})
\item Das Verzeichnis des \md{} dem \texttt{PATH} hinzufügen
\item Den \md{} starten -- mit \texttt{\$ micro-debug.sh -{}-help}
\end{enumerate}

Der \md{} kann durch einige Parameter gesteuert werden und wird nach dem Start durch Befehle gesteuert. Sowohl die Parameter als auch die Befehle werden nun erklärt und anschließend wird ein beispielhafter Ablauf mit dem \md{} beschrieben.

\section{Parameter}
Der Standardaufruf für den \md{} ist in Listing \ref{lst:aufruf-konsolenversion} zu sehen. Es gibt zwei verpflichtende Parameter: Die Pfade zur Mikro-Assembler- und zur Assembler-Bytecode-Datei\notiz{Irgendwo den Aufbau der beiden Dateien erwähnen}. Die beiden Pfade können sowohl relativ als auch absolut angegeben werden, wichtig ist allerdings, dass zuerst der Pfad zur Mikro-Assembler- und dann der Pfad zur assembler-Datei gegeben wird. Werden die beiden Pfade vertauscht, so startet der \md{} nicht und bricht mit einer Fehlermeldung ab.

\begin{lstlisting}[language=sh,caption={Aufruf des \md{} -- Konsolenversion},label=lst:aufruf-konsolenversion]
  micro-debug.sh [PARAMETER]... MIC1 IJVM
\end{lstlisting}

Neben den beiden Dateipfaden gibt es im folgende optionale Parameter. Jeder Parameter kann sowohl in der langen (mit doppeltem Minus) als auch in der kurzen (einfaches Minus gefolgt von einem Zeichen) angegeben werden.

\begin{description}
\item[-h, -{}-help]
  ist dieser Parameter gegeben, so wird die Hilfe angezeigt, die neben den verschiedenen Aufrufmöglichkeiten die möglichen Parameter erklärt. Zusätzlich werden noch einige andere Informationen, wie Kontaktmöglichkeiten, angezeigt.

\item[-o, -{}-output-file FILE]
  ermöglicht die Umlenkung der Ausgabe der \mic{} (nicht des \md{}) in eine Datei. Normalerweise wird die Ausgabe der \mic{} auf der Konsole ausgegeben.

  Mit dem Argument \texttt{FILE} wird hier der Pfad zur Datei gegeben, in die die Ausgabe geschrieben werden soll. Wenn die Datei bereits existiert, wird die Ausgabe an das Ende der Datei angehängt.

  Unter Linux kann man dann in einer zweiten Konsole diese Datei beispielsweise mit \texttt{tail -f} anzeigen und die Ausgabe der \mic{} komfortabel von der Ausgabe des \md{} trennen. In diesem Szenario ist auch der Parameter \texttt{-{}-unbuffered-output} sinnvoll.
\item[-u, -{}-unbuffered-output]
  verhindert die Pufferung der Ausgabe der \mic{}. Normalerweise gibt der \md{} die Ausgabe der \mic{} zeilenweise aus, also erst bei der Ausgabe eines Zeilenumbruchs. Verwendet man den Parameter \texttt{-{}-output-file} oder möchte man aus sonstigen Gründen jedes ausgegebene Zeichen der \mic{} direkt auf der Konsole sehen, so ist dieser Parameter die Lösung.

  \emph{Vorsicht!} Wird dieser Parameter ohne \texttt{-{}-output-file} genutzt, so kann es sehr schwer werden, die ausgegebenen Zeichen der \mic{} ausfindig zu machen, da sie womöglich in der Menge der Ausgaben von \md{} untergehen.

\item[-v, -{}-version]
  gibt die Version des \md{} aus.
\end{description}

Wenn einer der Parameter \texttt{-{}-help} oder \texttt{-{}-version} angegeben wurden, so startet der Debugger nicht. Dies kann genutzt werden, um ohne vorhandene Bytecode-Dateien Informationen über den \md{} anzeigen zu können. Listing \ref{lst:aufrufe-ohne-start} zeigt, dass der \md{} daher auch ohne Bytecode-Dateien aufgerufen werden kann.

\begin{lstlisting}[language=sh,caption={Aufruf des \md{} ohne Start -- Konsolenversion},label=lst:aufrufe-ohne-start]
  micro-debug.sh --help
  micro-debug.sh --version
\end{lstlisting}

Bei der Abarbeitung der gegebenen Parameter hängt die Reihenfolge der Parameter nicht von der Reihenfolge ab, in der sie dem \md{} als Parameter übergeben wurden. Wichtig ist nur, dass die beiden Bytecode-Dateien die letzten beiden Parameter und in der richtigen Reihenfolge aufgeführt sind.

\section{Befehle}
Ist der \md{} gestartet lässt er sich durch verschiedene Befehle steuern, die am Ende dieses Abschnitt ausführlich beschrieben werden.

Bei der Bedienung des \md{} gibt es die Möglichkeit, dass zwischen den verschiedenen Befehlen auch Eingaben für die \mic{} zu liefern sind. Damit der Benutzer sieht, ob die Eingabe vom \md{} oder der \mic{} erwartet wird, schreibt der \md{} '\texttt{micro-debug> }' und die \mic{} '\texttt{mic1> }' bevor eine Eingabe erwartet wird.

Die verschiedenen Befehle können ein oder mehrere Argumente benötigen. Die Argumente können einem der folgenden Datentypen gehören:
\begin{description}
\item[Register] ist der Name eines Registers, also \reg{CPP}, \reg{H}, \reg{LV}, \reg{MAR}, \reg{MBR}, \reg{MBRU}, \reg{MDR}, \reg{OPC}, \reg{PC}, \reg{SP} oder \reg{TOS}.
\item[Zahl] ist eine Zahl im Wertebereich eines Integers\notiz{Verweis?}. Die Formate für die Eingabe der Zahl sind in Abschnitt \ref{zahlenformat} beschrieben.
\end{description}

Je nach Befehl kann der zulässige Wertebereich jedoch noch weiter eingeschränkt sein -- eine solche Einschränkung ergibt sich aus der Beschreibung des jeweiligen Befehls.

\begin{description}
\item[break] \emph{Register [Zahl]}

  setzt einen Breakpoint für das gegebene \emph{Register}: Sobald das Register den Wert \emph{Zahl} erhält, hält der \md{}. Der \md{} hält erst, nachdem das Register den Wert erhalten hat -- da dies unter Umständen zu spät ist, gibt es die Möglichkeit, das Argument \emph{Zahl} wegzulassen. Wird nur ein Register angegeben, hält der \md{} bevor das Register einen neuen Wert zugewiesen bekommt.

\item[exit] \hspace*{\fill}\\

  beendet den \md{} und gibt eventuell belegte Ressourcen wieder frei.

\item[help] \hspace*{\fill}\\

  zeigt die verfügbaren Befehle mit einer kurzen Beschreibung an. Auch hier sind noch einige weitere Informationen über das Projekt enthalten.

\item[ls-break] \hspace*{\fill}\\

  zeigt alle Breakpoints mit deren jeweiligen Bedingung an. Jeder Breakpoint erhält eine Identifikationsnummer, die bei anderen Operationen, wie dem Entfernen, angegeben werden müssen.

\item[ls-macro-code] \emph{[Zahl1 [Zahl2]]}

  zeigt den disassemblierten Assembler-Code an. Dabei gibt es drei mögliche Konstellationen der Parameter:
  \begin{itemize}
  \item Wird kein Parameter gegeben, wird der vollständige Assembler-Code angezeigt.
  \item Wird ein Parameter \emph{Zahl1} gegeben, wird die angegebene Anzahl an Zeilen vor und nach der nächsten auszuführenden Codezeile angezeigt.
  \item werden beide Parameter gegeben, wird der Assembler-Code von Zeile \emph{Zahl1} bis zur Zeile \emph{Zahl2} (inklusive) angezeigt.
  \end{itemize}

  Da der \md{} nur den Bytecode kennt, gibt es eigentlich keine Zeilen. Der \md{} schreibt pro Zeile einen Befehl (inklusive Argumente), somit existieren Zeilennummern, die für den \md{} als Referenz dienen.

\item[ls-micro-code] \emph{[Zahl1 [Zahl2]]}

  zeigt den disassemblierten Mikro-Assembler-Code an und arbeitet wie \texttt{ls-macro-code}. Es gibt drei mögliche Konstellationen der Parameter:
  \begin{itemize}
  \item Wird kein Parameter gegeben, wird der vollständige Mikro-Assembler-Code angezeigt.
  \item Wird ein Parameter \emph{Zahl1} gegeben, wird die angegebene Anzahl an Zeilen vor und nach der nächsten auszuführenden Codezeile angezeigt.
  \item werden beide Parameter gegeben, wird der Mikro-Assembler-Code von Zeile \emph{Zahl1} bis zur Zeile \emph{Zahl2} (inklusive) angezeigt.
  \end{itemize}

  Da der \md{} nur den Bytecode kennt, gibt es eigentlich keine Zeilen. Der \md{} schreibt pro Zeile eine Mikroinstruktion (die $36~Bit$, die die Instruktion spezifizieren), somit existieren Zeilennummern, die für den \md{} als Referenz dienen.

\item[ls-mem] \emph{Zahl1 Zahl2}

  zeigt den Inhalt des Hauptspeichers zwischen den Adressen (inklusive) \emph{Zahl1} und \emph{Zahl2} an. Die Adressen des Speichers sind Wortadressen -- jedes Wort enthält $32~Bit$.

\item[ls-reg] \emph{[Register]}

  zeigt den Wert von dem gegebenen \emph{Register} an; wird das optionale Argument weggelassen, werden alle Register und deren Werte angezeigt.

\item[ls-stack] \hspace*{\fill}\\

  zeigt den aktuellen Stack an.

  \emph{Hinweis:} Dieser Befehl wird durch die Konfigurationsoption \texttt{stack.elements.to.hide} beeinflusst. Normalerweise wird der Stack von dem initialen Stackpointer bis zum aktuellen Stackpointer ausgegeben. Da dies unter Umständen mehr Elemente liefert, als der Stack tatsächlich enthält, gibt es die Möglichkeit über die Konfiguration die ersten Elemente nicht auszugeben.

Möchte man den realen (im Speicher vorhandenen) Stack sehen, sollte man sicherstellen, dass \texttt{stack.elements.to.hide = 0} konfiguriert ist.

\item[macro-break] \emph{Zahl}

  fügt einen Breakpoint hinzu, der den \md{} anhält, sobald der Bytecode des Assemblers an der Adresse \emph{Zahl} ausgeführt werden soll. \emph{Adresse} muss Element aus der Menge der von \texttt{ls-macro-code} angezeigten Zeilennummern sein.

\item[micro-break] \emph{Zahl}

  fügt einen Breakpoint hinzu, der den \md{} anhält, sobald der Bytecode des Mikro-Assemblers an der Adresse \emph{Zahl} ausgeführt werden soll. \emph{Adresse} muss Element aus der Menge der von \texttt{ls-micro-code} angezeigten Zeilennummern sein.

\item[micro-step] \emph{[Zahl]}

  führt die nächsten \emph{Zahl} Mikro-Instruktionen aus; wird kein Argument gegeben, so wird eine Instruktion ausgeführt.

\item[reset] \hspace*{\fill}\\

  die \mic{} wird in den Anfangszustand zurückgesetzt: Der Hauptspeicher und die Register werden auf die initialen Werte zurückgesetzt. Auch die Ein- und Ausgabe der \mic{} wird geleert. Die Informationen des \md{}, vor allem die Breakpoints, bleiben allerdings erhalten und müssen vom Benutzer nicht erneut gesetzt werden.

\item[rm-break] \emph{Zahl}

  entfernt den Breakpoint mit der Nummer \emph{Zahl}. Die Nummer des Breakpoints ist die Identifikationsnummer, die mit \texttt{ls-break} angezeigt wird.

\item[run] \hspace*{\fill}\\
  
  führt alle Instruktionen bis zum Programmende oder bis zum nächsten Breakpoint aus.

  \emph{Hinweis:} Unter Umständen und ungünstigem Programmcode kann das zu debuggende Programm in eine Schleife geraten, welche ohne Breakpoints nur durch den Programmabbruch beendet werden kann.

\item[set] \emph{Register Zahl}

  weist dem \emph{Register} den Wert \emph{Zahl} zu.

\item[set-mem] \emph{Zahl1 Zahl2}

  schreibt den Wert \emph{Zahl2} an die Wortadresse \emph{Zahl1} im Hauptspeicher.

  \emph{Hinweis:} Auch wenn dieser Befehl offensichtlich dazu genutzt werden könnte den Assembler-Code zu manipulieren, ist er für diesen Zweck nicht vorgesehen.

\item[step] \emph{[Zahl]}

  führt die nächsten \emph{Zahl} Instruktionen aus; wird kein Argument gegeben, so wird eine Instruktion ausgeführt.

\item[trace-mac] \hspace*{\fill}\\
  
  der Assembler-Code wird nun beobachtet. Dadurch wird jede Assembler-Instruktion angezeigt, nachdem sie ausgeführt wurde.

\item[trace-mic] \hspace*{\fill}\\

  der Mikro-Assembler-Code wird nun beobachtet. Dadurch wird jede Mikro-Assembler-Instruktion angezeigt, nachdem sie ausgeführt wurde.

\item[trace-reg] \emph{[Register]}

  das gegebene \emph{Register} wird nun beobachtet. Dadurch wird der Wert des Registers angezeigt, wenn er sich ändert. Wird das optionale Argument weggelassen, werden alle \emph{Register} beobachtet.

\item[trace-var] \emph{Zahl}

  die Variable \emph{Zahl} wird nun beobachtet. Dadurch wird der Inhalt der Variable angezeigt, wenn er sich ändert.

  \emph{Zahl} ist die Nummer der lokalen Variable. Wird eine Methode im Assembler-Code aufgerufen, ändert sich der Zeiger \reg{LV} und damit auch die Identität der lokalen Variablen. Wird also Variable Nummer~1 in Methode X beobachtet und führt der \md{} gerade Methode Y aus, wird eine Änderung der jetzigen lokalen Variable~1 nicht ausgegeben (sofern diese nicht auch beobachtet wird).

\item[untrace-mac] \hspace*{\fill}\\
  
  beendet das Beobachten des Assembler-Codes. Dadurch werden ausgeführte Assembler-Instruktionen nun nicht mehr ausgegeben.

\item[untrace-mic] \hspace*{\fill}\\

  beendet das Beobachten des Mikro-Assembler-Codes. Dadurch werden ausgeführte Mikro-Assembler-Instruktionen nun nicht mehr ausgegeben.

\item[untrace-reg] \emph{[Register]}

  beendet das Beobachten des gegebenen \emph{Register}s. Wird das optionale Argument weggelassen, wird nun kein Register mehr beobachtet.

\item[untrace-var] \emph{Zahl}

  beendet das Beobachten der lokalen Variable Nummer \emph{Zahl}.
\end{description}

\section{Tutorial}
