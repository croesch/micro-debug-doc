\chapter{Interaktion per Konsole}
\chplbl{bed-konsole}
Wie in \chpref{allgemein} beschrieben, muss der \md{} nicht installiert werden: Vom Herunterladen bis zum Starten des \md{} genügen folgende Schritte.

\begin{enumerate}
\item Die Datei \texttt{micro-debug-version.zip} von der Projektseite\notiz{Verweis auf Seite} herunterladen
\item Die \datei{zip} in ein beliebiges Verzeichnis entpacken (bspw. \texttt{/opt/micro-debug/})
\item Das Verzeichnis des \md{} dem \texttt{PATH} hinzufügen
\item Den \md{} starten -- mit \texttt{\$ micro-debug.sh -{}-help}
\end{enumerate}

Der \md{} kann durch einige Parameter gesteuert werden und wird nach dem Start durch Befehle gesteuert. Sowohl die Parameter als auch die Befehle werden nun erklärt und anschließend wird ein beispielhafter Ablauf mit dem \md{} beschrieben.

\section{Parameter}
Der Standardaufruf für den \md{} ist in \lstref{aufruf-konsolenversion} zu sehen. Es gibt zwei verpflichtende Parameter: Die Pfade zur Mikro-Assembler- und zur Assembler-Bytecode-Datei\notiz{Irgendwo den Aufbau der beiden Dateien erwähnen}. Die beiden Pfade können sowohl relativ als auch absolut angegeben werden, wichtig ist allerdings, dass zuerst der Pfad zur Mikro-Assembler- und dann der Pfad zur assembler-Datei gegeben wird. Werden die beiden Pfade vertauscht, so startet der \md{} nicht und bricht mit einer Fehlermeldung ab.

\begin{lstlisting}[language=sh,caption={Aufruf des \md{} -- Konsolenversion},label=\lstlbl{aufruf-konsolenversion}]
  micro-debug.sh [PARAMETER]... MIC1 IJVM
\end{lstlisting}

Neben den beiden Dateipfaden gibt es im folgende optionale Parameter. Jeder Parameter kann sowohl in der langen (mit doppeltem Minus) als auch in der kurzen (einfaches Minus gefolgt von einem Zeichen) angegeben werden.

\begin{description}
\item[-h, -{}-help]
  ist dieser Parameter gegeben, so wird die Hilfe angezeigt, die neben den verschiedenen Aufrufmöglichkeiten die möglichen Parameter erklärt. Zusätzlich werden noch einige andere Informationen, wie Kontaktmöglichkeiten, angezeigt.

\item[-o, -{}-output-file FILE]
  ermöglicht die Umlenkung der Ausgabe der \mic{} (nicht des \md{}) in eine Datei. Normalerweise wird die Ausgabe der \mic{} auf der Konsole ausgegeben.

  Mit dem Argument \texttt{FILE} wird hier der Pfad zur Datei gegeben, in die die Ausgabe geschrieben werden soll. Wenn die Datei bereits existiert, wird die Ausgabe an das Ende der Datei angehängt.

  Unter Linux kann man dann in einer zweiten Konsole diese Datei beispielsweise mit \texttt{tail -f} anzeigen und die Ausgabe der \mic{} komfortabel von der Ausgabe des \md{} trennen. In diesem Szenario ist auch der Parameter \texttt{-{}-unbuffered-output} sinnvoll.
\item[-u, -{}-unbuffered-output]
  verhindert die Pufferung der Ausgabe der \mic{}. Normalerweise gibt der \md{} die Ausgabe der \mic{} zeilenweise aus, also erst bei der Ausgabe eines Zeilenumbruchs. Verwendet man den Parameter \texttt{-{}-output-file} oder möchte man aus sonstigen Gründen jedes ausgegebene Zeichen der \mic{} direkt auf der Konsole sehen, so ist dieser Parameter die Lösung.

  \emph{Vorsicht!} Wird dieser Parameter ohne \texttt{-{}-output-file} genutzt, so kann es sehr schwer werden, die ausgegebenen Zeichen der \mic{} ausfindig zu machen, da sie womöglich in der Menge der Ausgaben von \md{} untergehen.

\item[-v, -{}-version]
  gibt die Version des \md{} aus.
\end{description}

Wenn einer der Parameter \texttt{-{}-help} oder \texttt{-{}-version} angegeben wurden, so startet der Debugger nicht. Dies kann genutzt werden, um ohne vorhandene Bytecode-Dateien Informationen über den \md{} anzeigen zu können. \lstref{aufrufe-ohne-start} zeigt, dass der \md{} daher auch ohne Bytecode-Dateien aufgerufen werden kann.

\begin{lstlisting}[language=sh,caption={Aufruf des \md{} ohne Start -- Konsolenversion},label=\lstlbl{aufrufe-ohne-start}]
  micro-debug.sh --help
  micro-debug.sh --version
\end{lstlisting}

Bei der Abarbeitung der gegebenen Parameter hängt die Reihenfolge der Parameter nicht von der Reihenfolge ab, in der sie dem \md{} als Parameter übergeben wurden. Wichtig ist nur, dass die beiden Bytecode-Dateien die letzten beiden Parameter und in der richtigen Reihenfolge aufgeführt sind.

\section{Befehle}
Ist der \md{} gestartet lässt er sich durch verschiedene Befehle steuern, die am Ende dieses Abschnitt ausführlich beschrieben werden.

Bei der Bedienung des \md{} gibt es die Möglichkeit, dass zwischen den verschiedenen Befehlen auch Eingaben für die \mic{} zu liefern sind. Damit der Benutzer sieht, ob die Eingabe vom \md{} oder der \mic{} erwartet wird, schreibt der \md{} '\texttt{micro-debug> }' und die \mic{} '\texttt{mic1> }' bevor eine Eingabe erwartet wird. Wenn die \mic{} eine Eingabe von Dir erwartet, kannst du mehrere Zeichen auf einmal eingeben -- an die \mic{} werden die von dir eingegebenen Zeichen plus ein Zeilenumbruch gesendet. Sollte dein Assembler-Code also in einer Schleife einzelne Zeichen einlesen, solltest du die gesamte Zeile direkt eingeben.

Die verschiedenen Befehle können ein oder mehrere Argumente benötigen. Die Argumente können einem der folgenden Datentypen gehören:
\begin{description}
\item[Register] ist der Name eines Registers, also \reg{CPP}, \reg{H}, \reg{LV}, \reg{MAR}, \reg{MBR}, \reg{MBRU}, \reg{MDR}, \reg{OPC}, \reg{PC}, \reg{SP} oder \reg{TOS}.
\item[Zahl] ist eine Zahl im Wertebereich eines Integers\notiz{Verweis?}. Die Formate für die Eingabe der Zahl sind in \secref{zahlenformat} beschrieben.
\end{description}

Je nach Befehl kann der zulässige Wertebereich jedoch noch weiter eingeschränkt sein -- eine solche Einschränkung ergibt sich aus der Beschreibung des jeweiligen Befehls.

\begin{description}
\item[break] \emph{Register [Zahl]}

  setzt einen Breakpoint für das gegebene \emph{Register}: Sobald das Register den Wert \emph{Zahl} erhält, hält der \md{}. Der \md{} hält erst, nachdem das Register den Wert erhalten hat -- da dies unter Umständen zu spät ist, gibt es die Möglichkeit, das Argument \emph{Zahl} wegzulassen. Wird nur ein Register angegeben, hält der \md{} bevor das Register einen neuen Wert zugewiesen bekommt.

\item[exit] \hspace*{\fill}\\

  beendet den \md{} und gibt eventuell belegte Ressourcen wieder frei.

\item[help] \hspace*{\fill}\\

  zeigt die verfügbaren Befehle mit einer kurzen Beschreibung an. Auch hier sind noch einige weitere Informationen über das Projekt enthalten.

\item[ls-break] \hspace*{\fill}\\

  zeigt alle Breakpoints mit deren jeweiligen Bedingung an. Jeder Breakpoint erhält eine Identifikationsnummer, die bei anderen Operationen, wie dem Entfernen, angegeben werden müssen.

\item[ls-macro-code] \emph{[Zahl1 [Zahl2]]}

  zeigt den disassemblierten Assembler-Code an. Dabei gibt es drei mögliche Konstellationen der Parameter:
  \begin{itemize}
  \item Wird kein Parameter gegeben, wird der vollständige Assembler-Code angezeigt.
  \item Wird ein Parameter \emph{Zahl1} gegeben, wird die angegebene Anzahl an Zeilen vor und nach der nächsten auszuführenden Codezeile angezeigt.
  \item werden beide Parameter gegeben, wird der Assembler-Code von Zeile \emph{Zahl1} bis zur Zeile \emph{Zahl2} (inklusive) angezeigt.
  \end{itemize}

  Da der \md{} nur den Bytecode kennt, gibt es eigentlich keine Zeilen. Der \md{} schreibt pro Zeile einen Befehl (inklusive Argumente), somit existieren Zeilennummern, die für den \md{} als Referenz dienen.

\item[ls-micro-code] \emph{[Zahl1 [Zahl2]]}

  zeigt den disassemblierten Mikro-Assembler-Code an und arbeitet wie \texttt{ls-macro-code}. Es gibt drei mögliche Konstellationen der Parameter:
  \begin{itemize}
  \item Wird kein Parameter gegeben, wird der vollständige Mikro-Assembler-Code angezeigt.
  \item Wird ein Parameter \emph{Zahl1} gegeben, wird die angegebene Anzahl an Zeilen vor und nach der nächsten auszuführenden Codezeile angezeigt.
  \item werden beide Parameter gegeben, wird der Mikro-Assembler-Code von Zeile \emph{Zahl1} bis zur Zeile \emph{Zahl2} (inklusive) angezeigt.
  \end{itemize}

  Da der \md{} nur den Bytecode kennt, gibt es eigentlich keine Zeilen. Der \md{} schreibt pro Zeile eine Mikroinstruktion (die $36~Bit$, die die Instruktion spezifizieren), somit existieren Zeilennummern, die für den \md{} als Referenz dienen.

\item[ls-mem] \emph{Zahl1 Zahl2}

  zeigt den Inhalt des Hauptspeichers zwischen den Adressen (inklusive) \emph{Zahl1} und \emph{Zahl2} an. Die Adressen des Speichers sind Wortadressen -- jedes Wort enthält $32~Bit$.

\item[ls-reg] \emph{[Register]}

  zeigt den Wert von dem gegebenen \emph{Register} an; wird das optionale Argument weggelassen, werden alle Register und deren Werte angezeigt.

\item[ls-stack] \hspace*{\fill}\\

  zeigt den aktuellen Stack an.

  \emph{Hinweis:} Dieser Befehl wird durch die Konfigurationsoption \texttt{stack.elements.to.hide} beeinflusst. Normalerweise wird der Stack von dem initialen Stackpointer bis zum aktuellen Stackpointer ausgegeben. Da dies unter Umständen mehr Elemente liefert, als der Stack tatsächlich enthält, gibt es die Möglichkeit über die Konfiguration die ersten Elemente nicht auszugeben.

Möchte man den realen (im Speicher vorhandenen) Stack sehen, sollte man sicherstellen, dass \texttt{stack.elements.to.hide = 0} konfiguriert ist.

\item[macro-break] \emph{Zahl}

  fügt einen Breakpoint hinzu, der den \md{} anhält, sobald der Bytecode des Assemblers an der Adresse \emph{Zahl} ausgeführt werden soll. \emph{Adresse} muss Element aus der Menge der von \texttt{ls-macro-code} angezeigten Zeilennummern sein.

\item[micro-break] \emph{Zahl}

  fügt einen Breakpoint hinzu, der den \md{} anhält, sobald der Bytecode des Mikro-Assemblers an der Adresse \emph{Zahl} ausgeführt werden soll. \emph{Adresse} muss Element aus der Menge der von \texttt{ls-micro-code} angezeigten Zeilennummern sein.

\item[micro-step] \emph{[Zahl]}

  führt die nächsten \emph{Zahl} Mikro-Instruktionen aus; wird kein Argument gegeben, so wird eine Instruktion ausgeführt.

\item[reset] \hspace*{\fill}\\

  die \mic{} wird in den Anfangszustand zurückgesetzt: Der Hauptspeicher und die Register werden auf die initialen Werte zurückgesetzt. Auch die Ein- und Ausgabe der \mic{} wird geleert. Die Informationen des \md{}, vor allem die Breakpoints, bleiben allerdings erhalten und müssen vom Benutzer nicht erneut gesetzt werden.

\item[rm-break] \emph{Zahl}

  entfernt den Breakpoint mit der Nummer \emph{Zahl}. Die Nummer des Breakpoints ist die Identifikationsnummer, die mit \texttt{ls-break} angezeigt wird.

\item[run] \hspace*{\fill}\\
  
  führt alle Instruktionen bis zum Programmende oder bis zum nächsten Breakpoint aus.

  \emph{Hinweis:} Unter Umständen und ungünstigem Programmcode kann das zu debuggende Programm in eine Schleife geraten, welche ohne Breakpoints nur durch den Programmabbruch beendet werden kann.

\item[set] \emph{Register Zahl}

  weist dem \emph{Register} den Wert \emph{Zahl} zu.

\item[set-mem] \emph{Zahl1 Zahl2}

  schreibt den Wert \emph{Zahl2} an die Wortadresse \emph{Zahl1} im Hauptspeicher.

  \emph{Hinweis:} Auch wenn dieser Befehl offensichtlich dazu genutzt werden könnte den Assembler-Code zu manipulieren, ist er für diesen Zweck nicht vorgesehen.

\item[step] \emph{[Zahl]}

  führt die nächsten \emph{Zahl} Instruktionen aus; wird kein Argument gegeben, so wird eine Instruktion ausgeführt.

\item[trace-mac] \hspace*{\fill}\\
  
  der Assembler-Code wird nun beobachtet. Dadurch wird jede Assembler-Instruktion angezeigt, nachdem sie ausgeführt wurde.

\item[trace-mic] \hspace*{\fill}\\

  der Mikro-Assembler-Code wird nun beobachtet. Dadurch wird jede Mikro-Assembler-Instruktion angezeigt, nachdem sie ausgeführt wurde.

\item[trace-reg] \emph{[Register]}

  das gegebene \emph{Register} wird nun beobachtet. Dadurch wird der Wert des Registers angezeigt, wenn er sich ändert. Wird das optionale Argument weggelassen, werden alle \emph{Register} beobachtet.

\item[trace-var] \emph{Zahl}

  die Variable \emph{Zahl} wird nun beobachtet. Dadurch wird der Inhalt der Variable angezeigt, wenn er sich ändert.

  \emph{Zahl} ist die Nummer der lokalen Variable. Wird eine Methode im Assembler-Code aufgerufen, ändert sich der Zeiger \reg{LV} und damit auch die Identität der lokalen Variablen. Wird also Variable Nummer~1 in Methode X beobachtet und führt der \md{} gerade Methode Y aus, wird eine Änderung der jetzigen lokalen Variable~1 nicht ausgegeben (sofern diese nicht auch beobachtet wird).

\item[untrace-mac] \hspace*{\fill}\\
  
  beendet das Beobachten des Assembler-Codes. Dadurch werden ausgeführte Assembler-Instruktionen nun nicht mehr ausgegeben.

\item[untrace-mic] \hspace*{\fill}\\

  beendet das Beobachten des Mikro-Assembler-Codes. Dadurch werden ausgeführte Mikro-Assembler-Instruktionen nun nicht mehr ausgegeben.

\item[untrace-reg] \emph{[Register]}

  beendet das Beobachten des gegebenen \emph{Register}s. Wird das optionale Argument weggelassen, wird nun kein Register mehr beobachtet.

\item[untrace-var] \emph{Zahl}

  beendet das Beobachten der lokalen Variable Nummer \emph{Zahl}.
\end{description}

\section{Tutorial}
Du solltest den \md{}, wie zu Beginn dieses Kapitels beschrieben, nun entpackt haben und am besten schon der \texttt{PATH}-Variable hinzugefügt haben. Denn dann kannst du in einem Verzeichnis deiner Wahl die Dateien für dieses Tutorial anlegen.

Wir möchten nun ein kleines Programm schreiben und dies testen: ein Programm zum Einlesen von Binärzahlen. \lstref{binary-read-c} zeigt den Code für das Programm in C\notiz{C referenz? erklärn?} und soll hier als Verständnis des Algorithmuses dienen.

\begin{lstlisting}[language=c,caption={C-Programm zum Einlesen einer Binärzahl},label=\lstlbl{binary-read-c}]
int main() {
  int character = 0;
  int result = 0;
  while(1) {
    character = getchar();
    if( c == '\n' ) {
      return result;
    }
    c = c - '0';
    result = 2 * result + c;
  }
}
\end{lstlisting}

Das entsprechende Assembler-Programm findest Du in \lstref{binary-read-jas}. Dieses Programm solltest du nun kompilieren -- \emph{Ray Ontko} stellt dafür in \cite{Ontko1999} einige Programme bereit: \texttt{mic1asm} zum Kompilieren des Mikro-Assembler-Codes und \texttt{ijvmasm} zum Kompilieren des Assembler-Codes. In \cite{Ontko1999} findest du auch den Mikro-Assembler-Code und eine entsprechende \texttt{ijvm.conf}-Datei.

\begin{lstlisting}[language=,caption={IJVM-Assembler zum Einlesen einer Binärzahl},label=\lstlbl{binary-read-jas}]
.main
.var
    c
    result
.end-var
    bipush      0
    istore      result
loop:
    in
    istore      c
    iload       c
    bipush      10
    if_icmpeq   finish
    iinc        c       -48
    iload       result
    dup
    iadd
    iload       c
    iadd
    goto        loop
finish:
    iload       result
    halt
.end-main
\end{lstlisting}

Zum Debuggen des Mikro-Assembler-Codes und Assembler-Codes solltest Du die \texttt{ijvm.conf}-Datei verwenden, die Du zum Kompilieren der \datei{mic1} genutzt hast. Diese \date{conf} kannst Du entweder in das \texttt{conf/} Verzeichnis des Debuggers legen, oder jeweils in dem Verzeichnis, in dem Du gerade arbeitest. Dass Du nicht die korrekte \texttt{ijvm.conf}-Datei verwendest, siehst Du beim Ausführen des Befehls \texttt{ls-macro-code} -- zeigt dieser unbekannte Assembler-Befehle, enthält der Assembler-Code Befehle, die in der \texttt{ijvm.conf} nicht oder nicht an dieser Adresse definiert sind.

Bevor wir nun beginnen solltest Du auch die Konfigurationsoption \texttt{mic1.micro.address.ijvm} überprüfen. Diese Option enthält die Adresse der Mikro-Instruktion, die von allen Mikro-Code-Methoden angesprungen wird, um die nächste Mikro-Instruktion zu \emph{laden}. Ist diese Option falsch konfiguriert, funktioniert später der Befehl \texttt{step} nicht wie erwartet.

Die in \lstref{binary-read-jas} aufgeführte Methode soll später eine eigene Methode werden und gibt daher keinen Wert aus, sondern legt das Ergebnis am Ende auf den Stack. \lstref{tutorial-start} zeigt in \srcref{tutorial-startbefehl} den Befehl, um den \md{} zu starten -- im aktuellen Verzeichnis liegen die Dateien \texttt{mic1ijvm.mic1}, \texttt{binary-read.ijvm} und \texttt{ijvm.conf}.

\begin{lstlisting}[language=,caption={Start des \md{}},label=\lstlbl{tutorial-start}]
micro-debug.sh mic1ijvm.mic1 binary-read.ijvm(*@\srclbl{tutorial-startbefehl}@*)
MicroDebug - Copyright (C) 2011-2012 Christian Roesch AND 1999 Prentice-Hall, Inc. (*@\srclbl{tutorial-start-willkommen}@*)
Welcome! Please type 'help' for a list of valid commands
----------------------------------------
micro-debug> (*@\srclbl{tutorial-start-mdread}@*)
\end{lstlisting}

Ab \srcref{tutorial-start-willkommen} steht die Willkommensnachricht des \md{} gefolgt von der \srcref{tutorial-start-mdread}, die anzeigt, dass der \md{} nun einen Befehl erwartet. Wir können uns nun eine ausführliche Beschreibung der verschiedenen Befehle anzeigen, mit dem Befehl \texttt{help}.

Geben wir den Befehl \texttt{ls-macro-code} ein, erhalten wir den disassemblierten Assembler-Code, wie in \lstref{tutorial-macro-code} zu sehen. Die Ausgabe zeigt zunächst pro Zeile die Assembler-Code-Zeile, dann die Adresse des Befehls im Mikro-Assembler-Code und anschließend den Namen des Befehls mit seinen Argumenten. Die Ausgabe ist nicht identisch mit dem Code, den wir anfangs kompiliert haben -- in \lstref{binary-read-jas} -- in der disassemblierten Variante fehlen Informationen wie Kommentare, Variablennamen und Sprungmarkennamen. Beispielsweise zeigt \srcref{tutorial-macro-code-sprung} einen bedingten Sprung zur Zeile \texttt{0x1B}.

\begin{lstlisting}[language=,caption={Disassemblierter Assembler-Code},label=\lstlbl{tutorial-macro-code}]
     0x0: [ 0x10] BIPUSH  0x0
     0x2: [ 0x36] ISTORE  1
(*@\srclbl{tutorial-macro-code-in}@*)     0x4: [ 0xFC] IN 
     0x5: [ 0x36] ISTORE  0
     0x7: [ 0x15] ILOAD  0
     0x9: [ 0x10] BIPUSH  0xA
(*@\srclbl{tutorial-macro-code-sprung}@*)     0xB: [ 0x9F] IF_ICMPEQ  0x1B
     0xE: [ 0x84] IINC  0 0x0
    0x11: [ 0x15] ILOAD  1
    0x13: [ 0x59] DUP 
    0x14: [ 0x60] IADD 
    0x15: [ 0x15] ILOAD  0
    0x17: [ 0x60] IADD 
    0x18: [ 0xA7] GOTO  0x4
    0x1B: [ 0x15] ILOAD  1
    0x1D: [ 0xFF] HALT 
\end{lstlisting}

Das erwartete Ergebnis eines Programmlaufs ist, dass wir die eingegebene Binärzahl am Ende auf dem Stack und damit im Register \reg{TOS} vorfinden -- geben wir $1010$ ein, soll \reg{TOS} nach einem Programmdurchlauf den Wert $10$ enthalten.

Mit dem Befehl \texttt{run} lassen wir das Programm nun zunächst ohne Breakpoints laufen. Nachdem wir das Programm gestartet haben, wird die \mic{} in \srcref{tutorial-macro-code-in} aus \lstref{tutorial-macro-code} mit dem Befehl \texttt{IN} Zeichen einlesen. Das erkennst Du auf der Konsole an der \srcref{tutorial-mic-eingabe-txt} aus \lstref{tutorial-mic-eingabe} -- statt \texttt{micro-debug>} steht hier nun \texttt{mic1>}.

\begin{lstlisting}[language=,caption={\mic{} erwartet Eingabe},label=\lstlbl{tutorial-mic-eingabe}]
micro-debug> run
mic1> (*@\srclbl{tutorial-mic-eingabe-txt}@*)
\end{lstlisting}

Wir geben nun \texttt{1010} ein und bestätigen die Eingabe mit \texttt{ENTER} -- dadurch werden fünf Zeichen im \md{} gepuffert: Die vier Zeichen, die wir eingegeben haben plus ein Zeilenumbruch. Jedes Mal, wenn die \mic{} nun ein Zeichen benötigt, wird aus diesem Puffer gelesen. Erst wenn dieser leer ist, erscheint erneut die Eingabeaufforderung für den Benutzer.

\begin{lstlisting}[language=,caption={\md{} gibt Anzahl ausgeführter Zyklen aus},label=\lstlbl{tutorial-durchgelaufen}]
Processor executed 441 ticks.
micro-debug> 
\end{lstlisting}

Nachdem wir nun die Zahl eingegeben haben erscheint die Ausgabe aus \lstref{tutorial-durchgelaufen}, die uns anzeigt, dass die \mic{} insgesamt $441$ Zyklen ausgeführt hat. Da unser Programm keine Ausgabe macht, sondern das Ergebnis auf den Stack (und damit in dem Register \reg{TOS}) ablegt, überprüfen wir das nun wie folgt. Mit dem Befehl \texttt{ls-reg} lassen wir uns wie in \lstref{tutorial-tos-falscher-wert} zu sehen den Inhalt des Registers \reg{TOS} anzeigen.

Das Register \reg{TOS} enthält den Wert $0$ und damit einen falschen Wert. Wir können nun noch den Stack anzeigen, um zu überprüfen, ob dort der erwartete Wert $10$ abgelegt ist. Den Stack zeigen wir mit dem Befehl \texttt{ls-stack} an, was die in \lstref{tutorial-stack} gezeigte Ausgabe liefert.

\begin{lstlisting}[language=,caption={\md{} gibt Anzahl ausgeführter Zyklen aus},label=\lstlbl{tutorial-tos-falscher-wert}]
micro-debug> ls-reg TOS
Register TOS : 0x0
micro-debug> 
\end{lstlisting}

Der erwartete Wert $10$ liegt auch nicht auf dem Stack. Wäre der Wert auf dem Stack, aber nicht im Register \reg{TOS} wäre das ein Hinweis auf einen Fehler im Mikro-Assembler-Code, da dieser für die Einhaltung der Regel zuständig ist, dass das Register \reg{TOS} stets den Wert des obersten Elements des Stacks enthält.

\begin{lstlisting}[language=,caption={Inhalt des Stacks nach der Ausführung des Assembler-Programms},label=\lstlbl{tutorial-stack}]
Stack value #1 [  0xC001]: 0x1
Stack value #2 [  0xC002]: 0x0
Stack value #3 [  0xC003]: 0x1
Stack value #4 [  0xC004]: 0x0
Stack value #5 [  0xC005]: 0x0
micro-debug> 
\end{lstlisting}

Damit wir das Programm erneut ablaufen lassen können, müssen wir die \mic{} auf ihren Startzustand zurücksetzen; mit dem Befehl \texttt{reset}.