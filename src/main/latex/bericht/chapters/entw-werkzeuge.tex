\chapter{Werkzeuge}
\chplbl{werkzeuge}
In diesem Teil der Arbeit möchte ich besonders eine Frage beantworten: Wie sind die bisher vorgestellten Funktionen des Debuggers implementiert? Mein Ziel ist, die Implementierung und Struktur des Debuggers so nachvollziehbar zu beschreiben, dass Leser mit Programmiererfahrung in der Lage sind, den Debugger weiterzuentwickeln.

Der Debugger soll auch nach Ende dieser Arbeit weiterentwickelt werden können. Daher stelle ich in diesem Kapitel vor, welche Werkzeuge ich zur Entwicklung des Debuggers nutze und wie diese zur Mitarbeit genutzt werden können. Dies ist nicht als Bedienungsanleitung zu verstehen! Ich bin aber der Ansicht, dass es das Verständnis für die Implementierung und meine Arbeit steigert, wenn geklärt ist, welche Werkzeuge ich wie nutze.

\section{Versionskontrollsystem}
Die Projekte \md und \mdg sind bei \name{GitHub} (siehe \cite{Roesch2012,Roesch2012gui}) gehostet und sind somit mit \gls{git} versioniert.

\gls{git} wird beispielsweise in \cite{Ohne1} beschrieben und ist demnach:
\begin{description}
\item[effizient] Auch bei großen Projekten zeigen Vergleiche, dass \gls{git} insgesamt schneller ist, als beispielsweise \gls{svn}.
\item[verteilt] Jeder Entwickler erhält ein lokales Repository und kann damit arbeiten. Es wird kein zentraler Server benötigt, alle Funktionen des Systems und alle Versionen stehen lokal zur Verfügung.
\item[sicher] Bei \gls{git} wird jeder Commit gehasht. Es ist praktisch nicht möglich einen Commit zu manipulieren, da dies die Hash-Summe verändern würde. Auch wenn theoretisch Kollisionen der Hash-Summe möglich sind, ist bisher eine solche Kollision noch nicht konstruierbar -- bei einem Code-Projekt müsste eine solche Kollision zudem kompilierbarer Code sein, was als hinreichend unwahrscheinlich gilt.
\end{description}

Ich habe \gls{git} gewählt, da dadurch später leicht \emph{forks}\footnote{Zu deutsch Abspaltung, ist ein Entwicklungszweig, nachdem sich ein Software-Projekt in zwei oder mehr Teile geteilt hat. Diese Teile werden meist unabhängig voneinander weiterentwickelt. Im täglichen Arbeitsablauf mit \gls{git} ist ein fork aber auch die Möglichkeit Neuerungen für ein Projekt zu Entwickeln und den entstandenen Entwicklungszeig nach Fertigstellung der Neuerung in das Ursprungsprojekt einzupflegen.} gebildet werden können und der Debugger durch Außenstehende weiterentwickelt werden kann. Das dezentrale Entwickeln mit \gls{git} ermöglicht es zusätzlich, dass später viele Entwickler am Debugger mitentwickeln.

Wie checkt man mit \gls{git} den Quelltext der Arbeit aus? Wie unterstützt mich \gls{git}, wenn ich das Projekt weiterentwickeln möchte? Im Folgenden möchte ich auf diese Fragen antworten. Ich möchte keine umfassende Bedienungsanleitung für \gls{git} geben, sondern die Grundlagen für die alltägliche Arbeit mit \gls{git} vermitteln. \gls{git} am \md erklären, für \mdg ist das Vorgehen analog, in den meisten Fällen muss lediglich ein \texttt{-gui} eingefügt werden.

\subsection{Code auschecken}
\seclbl{git-checkout}
Die Adresse des öffentlichen Repositorys lautet: \code{https://github.com/croesch/micro-debug.git}

\begin{lstlisting}[language=sh,caption={\md mit git auschecken},label=\lstlbl{git-auschecken}]
git clone git://github.com/croesch/micro-debug.git
cd micro-debug(*@\srclbl{git-auschecken-cd}@*)
\end{lstlisting}

Durch das Auschecken des Repositorys wird im aktuellen Verzeichnis ein Verzeichnis \texttt{micro-debug} angelegt. In diesem Verzeichnis wird zum einen der Inhalt des Repositorys abgelegt, als auch eine Kopie des Repositorys -- im Verzeichnis \texttt{micro-debug/.git}. \lstref{git-auschecken} zeigt, welcher Befehl zum Auschecken des Repositorys verwendet wird -- in \srcref{git-auschecken-cd} wird in das erzeugte Verzeichnis gewechselt, das Arbeitsverzeichnis.

Im Gegensatz zu \gls{svn} erstellt \gls{git} nur im Wurzelverzeichnis eines Projekts ein Verzeichnis \texttt{.git}. Direkt nach dem Klonen (bei \gls{git} für Auschecken) eines anderen Repositorys enthält es beispielsweise einen Verweis (\emph{origin}) auf dieses Repository. Sobald das geklonte Repository neuere Commits enthält, kann dieser Verweis genutzt werden, um wie in \lstref{git-pull} die neuen Commits in das lokale Repository zu übernehmen.

\begin{lstlisting}[language=sh,caption={Mit git \emph{pull} auf Originalrepository ausführen},label=\lstlbl{git-pull}]
git pull origin
\end{lstlisting}

Mit diesem Befehl werden die neuen Commits heruntergeladen und direkt in den aktuellen Branch eingefügt.

Dieses Vorgehen ist aufgrund der Änderung des aktuellen Branches häufig unerwünscht, daher kann man den Befehl aus \lstref{git-pull} wie in \lstref{git-fetch-merge} in zwei Befehle aufteilen, um zu regeln, ob und welcher Branch die Neuerungen erhält.

\begin{lstlisting}[language=sh,caption={\emph{pull} in zwei Befehlen manuell ausführen},label=\lstlbl{git-fetch-merge}]
git fetch origin(*@\srclbl{git-fetch-fetch}@*)
git merge origin/master(*@\srclbl{git-fetch-merge}@*)
\end{lstlisting}

Mit \emph{fetch} in \srcref{git-fetch-fetch} werden die Aktualisierungen heruntergeladen und zunächst im \texttt{.git}-Verzeichnis gespeichert. Erst der Befehl \emph{merge} in \srcref{git-fetch-merge} verändert die lokalen Dateien im aktuellen Branch.

\subsection{Code beitragen}
Hat man ein Repository geklont und möchte Codeänderungen dem Originalrepository zuführen, gibt es zwei Möglichkeiten: Man benutzt den Standard-Branch oder so genannte Feature-Branches.

Den Standard-Branch zu nutzen, empfehle ich nur für die Entwicklung als Einzelperson. Entwickelt man alleine an einem Projekt, kann man veränderte Dateien wie folgt committen:
\begin{verbatim}
$ git add relativer-pfad-zur-datei
$ git commit -m "Commit-Nachricht"
\end{verbatim}

Für mehrköpfige Entwicklungsteams empfehle ich Feature-Branches zu nutzen, da \gls{git} gute branch-/merge-Qualitäten aufweist. Beispielsweise können Sie so selbst Code zu dem Projekt beitragen, indem Sie folgende Schritte durchführen:
\begin{enumerate}
\item Erstellen Sie unter \code{https://github.com/croesch/micro-debug/issues} ein Thema, das Ihre Entwicklung beschreibt.

\item Erstellen Sie einen lokalen Branch zu dem Thema, wobei die Nummer die Nummer des Themas ist:
\begin{verbatim}
$ git checkout -b 100-themen-titel
\end{verbatim}

\item Entwickeln Sie den Code weiter.

\item Committen Sie die Änderungen:
\begin{verbatim}
$ git add .
$ git commit -m 'Commit-Nachricht'
\end{verbatim}

\item Laden Sie den Stand des öffentlichen Repositories:
\begin{verbatim}
$ git fetch origin
\end{verbatim}

\item Aktualisieren Sie den lokalen master-Branch:
\begin{verbatim}
$ git checkout master
$ git pull origin master
\end{verbatim}

\item Wiederholen Sie die Schritte 2-6, bis Ihre Entwicklung abgeschlossen ist

\item Aktualisieren Sie den Punkt von dem Ihr Branch abgeht:
\begin{verbatim}
$ git checkout 100-themen-titel
$ git rebase master
\end{verbatim}

\item Stellen Sie Ihren Branch öffentlich zur Verfügung.
\begin{verbatim}
$ git push origin 100-themen-titel
\end{verbatim}
\end{enumerate}

Da Sie für dieses Projekt auf github keine Schreibberechtigung haben, ist der letzte Punkt nicht so einfach möglich. Daher wählt man besonders auf gitHub einen leicht anderen Weg, den ich nun kurz vorstellen möchte.

\subsection{Unterstützung durch gitHub}
Die Grundidee ist, ein beliebiges Repository auf github zu klonen, so dass dieser Klon wiederum öffentlich zugänglich ist. Sie klonen dann den Klon von github auf Ihren lokalen Rechner, um daran zu entwickeln. Anschließend können Sie Ihr Ergebnis durch Ihren github-Klon veröffentlichen, so dass diese Änderung wieder in das Originalprojekt einfließen kann. Diesen Prozess möchte ich nun erläutern.

\begin{enumerate}
\item Registrieren Sie sich auf github, um dort Projekte veröffentlichen zu können. Legen Sie ssh-Schlüsselpaare an und laden Sie Ihren öffentlichen Schlüssel auf Ihr Benutzerkonto, dass Sie sich später bei Schreiboperationen authentifizieren können.

\item Klicken Sie auf der Projektseite \code{https://github.com/croesch/micro-debug} den \emph{fork}-Button. Dadurch klont github das Projekt auf Ihr Benutzerkonto, wo es nun unter \code{https://github.com/ihr-name/micro-debug} verfügbar ist.

\item Klonen Sie Ihre Repository nun lokal, wie in \secref{git-checkout} beschrieben:
\begin{verbatim}
$ git clone git://github.com/ihr-name/micro-debug.git
$ cd micro-debug
\end{verbatim}

\item Da Ihr Repository unter \emph{origin} nun Ihren github-Klon referenziert, setzen Sie eine Referenz auf das Hauptprojekt:
\begin{verbatim}
$ git remote add original-projekt git://github.com/croesch/micro-debug.git
\end{verbatim}

\item Erstellen Sie unter \code{https://github.com/croesch/micro-debug/issues} ein Thema, das Ihre Entwicklung beschreibt.

\item Erstellen Sie einen lokalen Branch zu dem Thema, wobei die Nummer die Nummer des Themas ist:
\begin{verbatim}
$ git checkout -b 100-themen-titel
\end{verbatim}

\item Entwickeln Sie den Code weiter.

\item Committen Sie die Änderungen:
\begin{verbatim}
$ git add .
$ git commit -m 'Commit-Nachricht'
\end{verbatim}

\item Laden Sie den Stand des öffentlichen Repositories:
\begin{verbatim}
$ git fetch original-projekt
\end{verbatim}

\item Aktualisieren Sie den lokalen master-Branch:
\begin{verbatim}
$ git checkout master
$ git pull original-projekt master
\end{verbatim}

\item Wiederholen Sie die Schritte 2-6, bis Ihre Entwicklung abgeschlossen ist

\item Aktualisieren Sie den Punkt von dem Ihr Branch abgeht:
\begin{verbatim}
$ git checkout 100-themen-titel
$ git rebase master
\end{verbatim}

\item Veröffentlichen Sie Ihren fertigen Branch über Ihren github-Klon:
\begin{verbatim}
$ git push origin 100-themen-titel
\end{verbatim}

\item Klicken Sie auf Ihrer Projekt-Seite auf \emph{Pull-Request}. Anschließend kann Ihr neuer Branch beispielsweise von mir in das Originalprojekt eingepflegt werden. Dann können Sie und alle anderen, die das Projekt geklont haben, die Änderungen über \emph{fetch} in die geklonten Repositories übernehmen.
\end{enumerate}

Sie haben nun die Möglichkeit den aktuellen Code lokal zu bearbeiten und Änderungen zum Projekt beizutragen. Im Folgenden möchte ich das Build-Management-Werkzeug erläutern, dass ich zum Entwickeln nutze: \gls{mvn}.

\section{Build-Management}
\gls{mvn} ist ein Werkzeug zum Bauen von \gls{java}-Anwendungen. Meines Erachtens gibt es keine signifikanten Gründe für oder gegen die Nutzung von \gls{mvn}; stattdessen hätte ich auch \gls{ant} oder \gls{make} nutzen können. In diesem Abschnitt möchte ich die grundlegenden Befehle für die Arbeit mit \gls{mvn} erläutern.

Ich verwende \gls{mvn}, da hier viel implizites Wissen eingesetzt wird; dadurch wird der Konfigurationsaufwand geringer -- solange man den Konventionen der \gls{mvn}-Entwickler folgt. Zu dem impliziten Wissen gehört unter anderem:
\begin{itemize}
\item \gls{java}-Klassen befinden sich in \code{src/main/java/}
\item \gls{java} Test-Klassen befinden sich in \code{src/test/java/}
\item Kompilate und von \gls{mvn} generierte Klassen befinden sich in \code{target/}
\item Die explizite Konfiguration steht in der Datei \code{pom.xml}
\end{itemize}

\subsection{Code kompilieren}
Mit dem folgenden Befehl können Sie den Programmcode kompilieren; Testklassen werden dadurch weder kompiliert noch ausgeführt:
\begin{verbatim}
$ mvn compile
\end{verbatim}

\gls{mvn} erkennt verschiedene Abhängigkeiten. Das führt dazu, dass beim ersten Ausführen zunächst erstmal alle benötigten Bibliotheken heruntergeladen werden. Zusätzlich erkennt \gls{mvn} auch, ob für ein bestimmtes Ziel die Klassen zunächst kompiliert werden müssen.

Beispielsweise werden zum Packetieren einer Anwendung zunächst alle Klassen kompiliert, anschließend die Tests ausgeführt, bevor die Anwendung packetiert werden kann; dies geschieht mit:
\begin{verbatim}
$ mvn package
\end{verbatim}

\subsection{Tests ausführen}
Wenn Sie alle Tests ausführen möchten, können Sie dies mit folgendem Befehl erreichen:
\begin{verbatim}
$ mvn test
\end{verbatim}

Je nachdem, welche Metriken Sie per Plugins noch mit \gls{mvn} ausführen, kann es nötig sein die von \gls{mvn} generierten Dateien zu löschen. Beispielsweise bei Code-Coverage-Werkzeugen ist dies nötig; alle von \gls{mvn} generierten Dateien -- das Verzeichnis \code{target} -- entfernen Sie mit:
\begin{verbatim}
$ mvn clean
\end{verbatim}

\subsection{Abhängigkeiten ändern}
Die Date \code{pom.xml} enthält die explizite Konfiguration eines Projektes. Darin enthalten sind unter anderem der Name und die Version des Projekts, aber auch abhängige Projekte.

Beispielsweise nutzt diese Arbeit \gls{fest} als Test-Werkzeug, in der \code{pom.xml} steht dazu Folgendes:
\begin{verbatim}
<dependency>
    <groupId>org.easytesting</groupId>
    <artifactId>fest-swing</artifactId>
    <version>1.2.1</version>
    <scope>test</scope>
</dependency>
\end{verbatim}

Dort können Sie nun die Version des Werkzeugs ändern, die genutzt werden soll; oder den Bereich von \emph{test} auf \emph{runtime} erweitern. Anschließend empfehle ich die Dateien zu entfernen, die mit \gls{mvn} zuvor generiert wurden und \gls{mvn} auszuführen.
