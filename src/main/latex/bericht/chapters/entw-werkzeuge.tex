\chapter{Werkzeuge}
\chplbl{werkzeuge}
Mit diesem Teil der Arbeit möchte ich besonders eine Frage beantworten: Wie sind die bisher vorgestellten Funktionen des Debuggers implementiert? Mein Ziel ist, die Implementierung und Struktur des Debuggers so nachvollziehbar zu beschreiben, dass Sie in der Lage sind den Debugger weiterzuentwickeln.

Der Debugger soll auch nach Ende dieser Arbeit weiterentwickelt werden können. Daher stelle ich in diesem Kapitel vor, welche Werkzeuge ich zur Entwicklung des Debuggers nutze und wie Sie diese zur Mitarbeit nutzen können. Dies ist nicht als Bedienungsanleitung zu verstehen. Ich bin der Ansicht, dass es das Verständnis der Implementierung und meiner Arbeit steigert, wenn geklärt ist, welche Werkzeuge ich wie nutze.

\section{Versionskontrollsystem}
Das Projekt ist bei github % TODO Referenz
gehostet und ist somit mit \gls{git} versioniert.

\gls{git} % Quelle: http://git-scm.com/about 04.12.2011 14:00
ist:
\begin{description}
\item[effizient] Auch bei großen Projekten zeigen Vergleiche, %TODO Beleg
dass \gls{git} insgesamt schneller ist, als andere Versionskontrollsysteme.
\item[verteilt] Im Gegensatz zu beispielsweise CVS % TODO CVS
ist \gls{git} ein verteiltes Versionskontrollsystem: Jeder Entwickler erhält ein lokales Repository %TODO repository
und kann damit arbeiten. Es wird kein zentraler Server benötigt, alle Funktionen des Systems und Commit-Informationen stehen lokal zur Verfügung.
\item[sicher] %TODO nochmal genau nachschauen
Bei \gls{git} werden viele Hash-Summen gebildet und sobald ein Commit veröffentlich wurde, ist es nicht möglich diesen zu manipulieren, da dies die Hash-Summe %TODo welche genau?
verändern würde.
\end{description}

Ich habe \gls{git} gewählt, da dadurch später leicht forks %TODO fork
gebildet werden können und das Projekt für andere Arbeiten weitergeführt werden kann. Das dezentrale Entwickeln mit \gls{git} ermöglicht es zusätzlich, dass später viele Entwickler das Projekt weiterentwickeln.

Ich möchte nun kurz erläutern, wie man mit \gls{git} den Quelltext der Arbeit auscheckt. Zusätzlich möchte ich erläutern, wie Sie \gls{git} unterstützt, wenn Sie das Projekt weiterentwickeln möchten. Dadurch möchte ich keine umfassende Bedienungsanleitung für \gls{git} geben, sondern Ihnen die alltägliche Arbeit mit dem Werkzeug erklären.

\subsection{Code auschecken}
\seclbl{git-checkout}
Die Adresse des öffentlichen Repositories %TODO genitiv repository
lautet:
\code{https://github.com/croesch/micro-debug.git}

Das Auschecken des Repositories %TODO hier auch
erzeugt ein lokales Repository im Verzeichnis \emph{micro-debug}; mit folgenden Befehlen können Sie das Repository auschecken und anschließend in das erzeugte Verzeichnis wechseln:
\begin{verbatim}
$ git clone git://github.com/croesch/micro-debug.git
$ cd micro-debug
\end{verbatim}

Im Gegensatz zu SVN %TODO svn
erstellt \gls{git} nur im Wurzelverzeichnis eines Projektes einen Ordner \emph{.git}, dieser enthält alle Informationen über das Repository. Direkt nach dem Klonen eines anderen Repositories enthält es beispielsweise einen Verweis (\emph{origin}) auf dieses Repository, um Aktualisierungen zu erhalten.

Im Laufe der Zeit wird das öffentliche Repository aktuellere Commits enthalten, als Ihr lokales Repository. Aktualisiert man mit \gls{git} das Repository,
\begin{verbatim}
$ git pull origin
\end{verbatim}
so werden die neuen Commits heruntergeladen und direkt in den aktuell ausgecheckten Branch gemergt. %TODO denglisch

Dieses Vorgehen kann manchmal unerwünscht sein, so dass man zunächst das Repository aktualisieren möchte und später selbst mergen möchte:
\begin{verbatim}
$ git fetch origin
$ git merge origin/master
\end{verbatim}
Mit \emph{fetch} werden die Aktualisierungen zunächst nur im \emph{.git}-Verzeichnis gespeichert. Erst \emph{merge} verändert die lokalen Dateien im aktuellen Branch.

\subsection{Code beitragen}
Hat man ein lokales Repository ausgecheckt und möchte Codeänderungen dem Projekt beitragen, gibt es zwei Möglichkeiten: Man benutzt den Standard-Branch oder so genannte Feature-Branches.

Den Standard-Branch zu nutzen, empfehle ich nur für die Entwicklung als Einzelperson. Entwickelt man alleine an einem Projekt, kann man veränderte Dateien wie folgt committen:
\begin{verbatim}
$ git add relativer-pfad-zur-datei
$ git commit -m "Commit-Nachricht"
\end{verbatim}

Für mehrköpfige Entwicklungsteams empfehle ich Feature-Branches zu nutzen, da \gls{git} gute branch-/merge-Qualitäten aufweist. Beispielsweise können Sie so selbst Code zu dem Projekt beitragen, indem Sie folgende Schritte durchführen:
\begin{enumerate}
\item Erstellen Sie unter \code{https://github.com/croesch/micro-debug/issues} ein Thema, das Ihre Entwicklung beschreibt.

\item Erstellen Sie einen lokalen Branch zu dem Thema, wobei die Nummer die Nummer des Themas ist:
\begin{verbatim}
$ git checkout -b 100-themen-titel
\end{verbatim}

\item Entwickeln Sie den Code weiter.

\item Committen Sie die Änderungen:
\begin{verbatim}
$ git add .
$ git commit -m 'Commit-Nachricht'
\end{verbatim}

\item Laden Sie den Stand des öffentlichen Repositories:
\begin{verbatim}
$ git fetch origin
\end{verbatim}

\item Aktualisieren Sie den lokalen master-Branch:
\begin{verbatim}
$ git checkout master
$ git pull origin master
\end{verbatim}

\item Wiederholen Sie die Schritte 2-6, bis Ihre Entwicklung abgeschlossen ist

\item Aktualisieren Sie den Punkt von dem Ihr Branch abgeht:
\begin{verbatim}
$ git checkout 100-themen-titel
$ git rebase master
\end{verbatim}

\item Stellen Sie Ihren Branch öffentlich zur Verfügung.
\begin{verbatim}
$ git push origin 100-themen-titel
\end{verbatim}
\end{enumerate}

Da Sie für dieses Projekt auf github keine Schreibberechtigung haben, ist der letzte Punkt nicht so einfach möglich. Daher wählt man besonders auf gitHub einen leicht anderen Weg, den ich nun kurz vorstellen möchte.

\subsection{Unterstützung durch gitHub}
Die Grundidee ist, ein beliebiges Repository auf github zu klonen, so dass dieser Klon wiederum öffentlich zugänglich ist. Sie klonen dann den Klon von github auf Ihren lokalen Rechner, um daran zu entwickeln. Anschließend können Sie Ihr Ergebnis durch Ihren github-Klon veröffentlichen, so dass diese Änderung wieder in das Originalprojekt einfließen kann. Diesen Prozess möchte ich nun erläutern.

\begin{enumerate}
\item Registrieren Sie sich auf github, um dort Projekte veröffentlichen zu können. Legen Sie ssh-Schlüsselpaare an und laden Sie Ihren öffentlichen Schlüssel auf Ihr Benutzerkonto, dass Sie sich später bei Schreiboperationen authentifizieren können.

\item Klicken Sie auf der Projektseite \code{https://github.com/croesch/micro-debug} den \emph{fork}-Button. Dadurch klont github das Projekt auf Ihr Benutzerkonto, wo es nun unter \code{https://github.com/ihr-name/micro-debug} verfügbar ist.

\item Klonen Sie Ihre Repository nun lokal, wie in \secref{git-checkout} beschrieben:
\begin{verbatim}
$ git clone git://github.com/ihr-name/micro-debug.git
$ cd micro-debug
\end{verbatim}

\item Da Ihr Repository unter \emph{origin} nun Ihren github-Klon referenziert, setzen Sie eine Referenz auf das Hauptprojekt:
\begin{verbatim}
$ git remote add original-projekt git://github.com/croesch/micro-debug.git
\end{verbatim}

\item Erstellen Sie unter \code{https://github.com/croesch/micro-debug/issues} ein Thema, das Ihre Entwicklung beschreibt.

\item Erstellen Sie einen lokalen Branch zu dem Thema, wobei die Nummer die Nummer des Themas ist:
\begin{verbatim}
$ git checkout -b 100-themen-titel
\end{verbatim}

\item Entwickeln Sie den Code weiter.

\item Committen Sie die Änderungen:
\begin{verbatim}
$ git add .
$ git commit -m 'Commit-Nachricht'
\end{verbatim}

\item Laden Sie den Stand des öffentlichen Repositories:
\begin{verbatim}
$ git fetch original-projekt
\end{verbatim}

\item Aktualisieren Sie den lokalen master-Branch:
\begin{verbatim}
$ git checkout master
$ git pull original-projekt master
\end{verbatim}

\item Wiederholen Sie die Schritte 2-6, bis Ihre Entwicklung abgeschlossen ist

\item Aktualisieren Sie den Punkt von dem Ihr Branch abgeht:
\begin{verbatim}
$ git checkout 100-themen-titel
$ git rebase master
\end{verbatim}

\item Veröffentlichen Sie Ihren fertigen Branch über Ihren github-Klon:
\begin{verbatim}
$ git push origin 100-themen-titel
\end{verbatim}

\item Klicken Sie auf Ihrer Projekt-Seite auf \emph{Pull-Request}. Anschließend kann Ihr neuer Branch beispielsweise von mir in das Originalprojekt eingepflegt werden. Dann können Sie und alle anderen, die das Projekt geklont haben, die Änderungen über \emph{fetch} in die geklonten Repositories übernehmen.
\end{enumerate}

Sie haben nun die Möglichkeit den aktuellen Code lokal zu bearbeiten und Änderungen zum Projekt beizutragen. Im Folgenden möchte ich das Build-Management-Werkzeug erläutern, dass ich zum Entwickeln nutze: \gls{mvn}.

\section{Build-Management}
\gls{mvn} ist ein Werkzeug zum Bauen von \gls{java}-Anwendungen. Meines Erachtens gibt es keine signifikanten Gründe für oder gegen die Nutzung von \gls{mvn}; stattdessen hätte ich auch \gls{ant} oder \gls{make} nutzen können. In diesem Abschnitt möchte ich die grundlegenden Befehle für die Arbeit mit \gls{mvn} erläutern.

Ich verwende \gls{mvn}, da hier viel implizites Wissen eingesetzt wird; dadurch wird der Konfigurationsaufwand geringer -- solange man den Konventionen der \gls{mvn}-Entwickler folgt. Zu dem impliziten Wissen gehört unter anderem:
\begin{itemize}
\item \gls{java}-Klassen befinden sich in \code{src/main/java/}
\item \gls{java} Test-Klassen befinden sich in \code{src/test/java/}
\item Kompilate und von \gls{mvn} generierte Klassen befinden sich in \code{target/}
\item Die explizite Konfiguration steht in der Datei \code{pom.xml}
\end{itemize}

\subsection{Code kompilieren}
Mit dem folgenden Befehl können Sie den Programmcode kompilieren; Testklassen werden dadurch weder kompiliert noch ausgeführt:
\begin{verbatim}
$ mvn compile
\end{verbatim}

\gls{mvn} erkennt verschiedene Abhängigkeiten. Das führt dazu, dass beim ersten Ausführen zunächst erstmal alle benötigten Bibliotheken heruntergeladen werden. Zusätzlich erkennt \gls{mvn} auch, ob für ein bestimmtes Ziel die Klassen zunächst kompiliert werden müssen.

Beispielsweise werden zum Packetieren einer Anwendung zunächst alle Klassen kompiliert, anschließend die Tests ausgeführt, bevor die Anwendung packetiert werden kann; dies geschieht mit:
\begin{verbatim}
$ mvn package
\end{verbatim}

\subsection{Tests ausführen}
Wenn Sie alle Tests ausführen möchten, können Sie dies mit folgendem Befehl erreichen:
\begin{verbatim}
$ mvn test
\end{verbatim}

Je nachdem, welche Metriken Sie per Plugins noch mit \gls{mvn} ausführen, kann es nötig sein die von \gls{mvn} generierten Dateien zu löschen. Beispielsweise bei Code-Coverage-Werkzeugen ist dies nötig; alle von \gls{mvn} generierten Dateien -- das Verzeichnis \code{target} -- entfernen Sie mit:
\begin{verbatim}
$ mvn clean
\end{verbatim}

\subsection{Abhängigkeiten ändern}
Die Date \code{pom.xml} enthält die explizite Konfiguration eines Projektes. Darin enthalten sind unter anderem der Name und die Version des Projekts, aber auch abhängige Projekte.

Beispielsweise nutzt diese Arbeit \gls{fest} als Test-Werkzeug, in der \code{pom.xml} steht dazu Folgendes:
\begin{verbatim}
<dependency>
    <groupId>org.easytesting</groupId>
    <artifactId>fest-swing</artifactId>
    <version>1.2.1</version>
    <scope>test</scope>
</dependency>
\end{verbatim}

Dort können Sie nun die Version des Werkzeugs ändern, die genutzt werden soll; oder den Bereich von \emph{test} auf \emph{runtime} erweitern. Anschließend empfehle ich die Dateien zu entfernen, die mit \gls{mvn} zuvor generiert wurden und \gls{mvn} auszuführen.
