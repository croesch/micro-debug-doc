\chapter{Implementierung der GUI}
\chplbl{gui}
Nachdem wir nun ausführlich den \md{} betrachtet haben, möchte ich Dir nun vorstellen, wie die \mdg{} den \md{} nutzt und welche Klassen hier welche Rolle einnehmen. Ähnlich wie in \chpref{konsole} möchte ich im \secref{gui-ablauf} den Ablauf bei der Nutzung der \mdg{} vorstellen. In \secref{g-bibliotheken} möchte ich die verwendeten Bibliotheken vorstellen, die der Benutzer am Ende erhält und deren Bedeutung für die \mdg{} erläuetern. Am Ende dieses Kapitels möchte ich auch hier nochmal alle \packages{} aufführen und beschreiben, welche Funktionalität dahinter steckt und eventuell einzelne Klassen erwähnen.

Im Unterschied zur Implementierung des \md{} befinden sich in der \mdg{} alle Klassen im \package{} \pck{com.github.croesch.micro_debug.gui} oder in \subpackages{} davon. Das verhindert, dass gleichnamige \packages{} oder Klassen zu Problemen führen. Außerdem ist je nach Paketierung die Struktur der paketierten \mdg{} übersichtlicher.

\section{Programmablauf}
\seclbl{gui-ablauf}
Wie in \secref{k-ablauf} sehen wir uns gleich den Start der \mdg{} an und ich zeige, welche Klassen an welchen Aktionen beteiligt sind. Gelegentlich werde ich erwähnen, wo Zugriffe auf den \md{} stattfinden oder wann der Benutzer gefragt ist.

\subsection{Verarbeitung der Argumente}
Analog zum \md{} gibt es auch in der \mdg{} eine Klasse \klasse{MicroDebug}, die die \texttt{main()}-Methode enthält. Allerdings ist es hier irrelevant, wie viele Argumente der Benutzer eingegeben hat, oder ob er überhaupt welche eingegeben hat.

Die \mdg{} nutzt auch den Mechanismus der Klasse \klasse{AArgument}. Da die \mdg{} allerdings andere Argumente als der \md{} besitzt, müssen die neuen Argumente zunächste an der Klasse \klasse{AArgument} registriert werden. Die Argumente der \mdg{} findest Du im \package{} \pck{argument}; registriert werden diese in der Methode \texttt{createListOfPossibleArguments()} der Klasse \klasse{MicroDebug}.

Die Argumente werden dann auch ausgeführt und geben jeweils einen Wahrheitswert zurück, ob der Debugger starten darf oder nicht.

\subsection{Aufbau der grafischen Oberfläche}
Darf der Debugger starten, so wird eine Instanz der Klasse \klasse{Mic1Starter} erzeugt, die den Debugger starten kann. Zunächst erzeugt die Klasse jedoch das Startfenster, welches in der Klasse \klasse{StartFrame} definiert ist, und zeigt dieses an. Das Startfenster enthält einige Aktionsmöglichkeiten -- hat der Benutzer nun die richtigen Dateien ausgewählt und den Button zum Start gedrückt, wird an der Klasse \klasse{Mic1Starter} die Methode \texttt{create(String,String)} mit den zwei angegebenen Dateipfaden ausgeführt.

Wie in \secref{k-aufbau-debugger} wird nun anhand dieser Dateipfade versucht die \mic{} zu erzeugen. Gelingt dies nicht, wird das Startfenster erneut gezeigt. Hat der Benutzer zwei korrekte Dateien angegeben, wird das Hauptfenster aufgebaut und angezeigt, was in der Klasse \klasse{MainFrame} definiert ist.

In der Klasse \klasse{MainFrame} werden drei erwähnenswerte Objekte erzeugt: die \emph{View}, der \emph{Controller} und die \emph{Actions}. Die \emph{View} bildet die Oberfläche und ist zunächst in der Klasse \klasse{MainView} definiert, die wiederum weitere Klassen zur Darstellung der einzelnen Bereiche nutzt. Ein ähnliches Konzept nutzt der \emph{Controller}, der in der Klasse \klasse{MainController} definiert ist: Für die einzelnen kleinen \emph{Views} werden entsprechende \emph{Controller} erzeugt, die dadurch jeweils nur einen kleinen Aufgabenbereich erhalten. Das dritte Objekt ist von der Klasse \klasse{ActionProvider} und erzeugt die \emph{Actions}, die der Benutzer über die Oberfläche erreichen kann. Dieser \emph{ActionProvider} hält die Referenzen auf die \emph{Actions}, so dass nur dieses eine Objekt weitergereicht werden muss anstatt dutzender \emph{Actions}.

Diese \emph{Actions} werden dann noch in der \klasse{MainMenuBar} untergebracht und mit Tastenkombinationen versehen, die der Benutzer konfiguriert hat.

\subsection{Verarbeitung von Benutzeraktionen}
Nachdem die Oberfläche aufgebaut ist, sind die \emph{Actions} der Ausgangspunkt von weiteren Code-Ausführungen. Bis der Benutzer die \texttt{EXIT}-Aktion ausführt oder das Fenster schließt, läuft die \mdg{}.

In der Klasse \klasse{ActionProvider} werden die Referenzen auf die \emph{Actions} gehalten und unter den Schlüsseln abgelegt, die die Enumeration \klasse{Actions} bietet.

Bis auf einige Ausnahmen werden die ganzen \emph{Actions} auf dem \gls{edt} ausgeführt. Bei einigen \emph{Actions} wäre dies von Nachteil: spätestens wenn die \mic{} eine Eingabe erwarten würde, käme es zu einem Deadlock\notiz{Deadlock erklärn!?}. Denn die Eingabe für die \mic{} wird in der \mdg{} über ein Textfeld ausgeführt. Liest die \mic{} nun auf dem \gls{edt} ein Zeichen aus diesem Textfeld, obwohl dort noch keines eingegeben wurde, dann blockiert der aktuelle Thread (in diesem Fall der \gls{edt}) bis der Benutzer eine Eingabe gemacht hat. Eine Eingabe kann aber nur über den \gls{edt} ausgeführt werden, der noch blockiert ist -- ein Deadlock.

Aus diesem Grund gibt es die Klasse \klasse{AbstractExecuteOnWorkerThreadAction}. Jede \emph{Action}, die davon ableitet, wird nicht auf dem \gls{edt} ausgeführt sondern auf einer Instanz der Klasse \klasse{WorkerThread}. Dieser Thread läuft und arbeitet kontinuierlich Objekte der Klasse \klasse{Runnable} ab und wird hier genutzt, um solche Deadlocks zu umgehen.

\subsection{Konfiguration und Lokalisierung}

\section{Bibliotheken}
\seclbl{g-bibliotheken}

\section{\packages}